{"version":3,"sources":["services/DigitExtractor/DigitExtractor.ts","util/geometry.ts","services/lib/cv.ts","services/SudokuScanner/SudokuScanner.ts","util/camera.ts","components/SudokuSolver.tsx","App.tsx","reportWebVitals.ts","serviceWorkerRegistration.ts","index.tsx"],"names":["DigitExtractor","config","worker","language","tesseractConfig","tessedit_ocr_engine_mode","tessedit_pageseg_mode","tessedit_char_whitelist","user_defined_dpi","workerConfig","isNode","langPath","path","join","__dirname","cacheMethod","gzip","process","workerPath","corePath","this","createWorker","load","loadLanguage","initialize","setParameters","imageSource","recognize","data","text","slice","terminate","distance","x1","y1","x2","y2","closest","reference","points","distances","map","point","closestDistance","reduce","closestPoint","i","measureSides","coords","coord","length","isPointInsideRect","rect","x","y","width","height","getContourPathCoords","contour","pointVector","Array","from","data32S","simplifyContour","simplified","cv","Mat","epsilon","arcLength","approxPolyDP","isContourSquarish","container","minSize","maxSize","size","minArea","Math","min","rows","cols","sizeLimit","max","contourArea","sortedLengths","sort","longest","pop","every","cropAndFlatten","src","rectangleContour","sourceWidth","sourceHeight","contourCoords","topLeft","topRight","bottomLeft","bottomRight","newWidth","newHeight","flattened","zeros","CV_8UC3","Size","srcTri","matFromArray","CV_32FC2","dstTri","transformMatrix","getPerspectiveTransform","warpPerspective","INTER_LINEAR","BORDER_CONSTANT","delete","split","columns","squares","squareWidth","squareHeight","r","c","crop","Rect","roi","cropCellBorders","binary","cellCenter","round","cellArea","maxArea","contours","MatVector","hierarchy","findContours","RETR_TREE","CHAIN_APPROX_SIMPLE","largestArea","largestRect","get","boundingRect","area","shapeRatio","binaryCellContents","isCellEmpty","mean","CV_64F","stdDev","meanStdDev","doubleAt","isEmpty","padding","SudokuScanner","source","preprocess","blurRadius","thresholdBlur","thresholdNorm","original","processed","Error","constructor","name","matFromImageData","imread","clone","outputCanvas","preprocessImage","largestSquare","findLargestSquare","colour","imshow","undefined","extractSudokuImage","extractDigits","originalCells","binaryCells","grid","row","colourCell","binaryCell","digitMat","canvas","document","createElement","push","cvtColor","COLOR_RGBA2GRAY","blurKernel","GaussianBlur","BORDER_DEFAULT","adaptiveThreshold","ADAPTIVE_THRESH_MEAN_C","THRESH_BINARY","idealCameraConstraints","ideal","facingMode","focusMode","whiteBalance","exposureMode","identifyPrimaryCamera","a","navigator","mediaDevices","enumerateDevices","inputDevices","cameras","filter","device","kind","backFacingCameras","camera","label","includes","loadCameraStream","videoElement","dimensions","constraints","video","deviceId","audio","getUserMedia","srcObject","play","SudokuSolver","videoRef","useRef","canvasRef","streamRef","processStream","useCallback","input","output","frame","buffer","videoWidth","videoHeight","ctx","getContext","drawImage","getImageData","getFrame","current","scanner","destruct","requestAnimationFrame","useEffect","init","extractor","extractSingle","digit","console","log","cancelAnimationFrame","getVideoTracks","stop","ref","muted","playsInline","id","App","useState","loading","setLoading","style","position","top","left","onClick","type","onLoad","openCvPath","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","getElementById","serviceWorker","ready","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.d86349bb.chunk.js","sourcesContent":["import isNode from 'detect-node';\nimport path from 'path';\nimport { createWorker, ImageLike, PSM, Worker, WorkerOptions, WorkerParams } from 'tesseract.js';\n\nimport DigitExtractorInterface from '../../types/interfaces/DigitExtractor';\n\nexport default class DigitExtractor implements DigitExtractorInterface {\n  protected readonly worker: Worker;\n  protected readonly language = 'eng';\n  protected readonly tesseractConfig: Partial<WorkerParams> = {\n    tessedit_ocr_engine_mode: 2,\n    tessedit_pageseg_mode: '10' as PSM,\n    tessedit_char_whitelist: '0123456789',\n    user_defined_dpi: '300',\n  };\n\n  constructor(config?: Partial<WorkerParams>) {\n    // Configure Tesseract worker to not make external download requests...\n    const workerConfig: Partial<WorkerOptions> = isNode\n      ? {\n          langPath: path.join(__dirname, '..', '..', '..', `public/ocr`),\n          // It should be faster to cache the uncompressed lang data, although there seems to be no\n          // real difference in practice; so we may as well keep the repo smaller.\n          cacheMethod: 'none',\n          gzip: true,\n        }\n      : {\n          langPath: `${process.env.PUBLIC_URL}/ocr`,\n          workerPath: `${process.env.PUBLIC_URL}/ocr/worker.min.js`,\n          corePath: `${process.env.PUBLIC_URL}/ocr/tesseract-core.wasm.js`,\n        };\n    this.worker = createWorker(workerConfig);\n    this.tesseractConfig = { ...this.tesseractConfig, ...config };\n  }\n\n  /** @inheritDoc */\n  public async load() {\n    await this.worker.load();\n    await this.worker.loadLanguage(this.language);\n    await this.worker.initialize(this.language);\n    await this.worker.setParameters(this.tesseractConfig);\n  }\n\n  /** @inheritDoc */\n  public async extractSingle(imageSource: ImageLike): Promise<string> {\n    // TODO: Check other returned symbols and use Sudoku constraints to inform selection.\n    const { data } = await this.worker.recognize(imageSource);\n\n    return data.text.slice(0, 1); // Tesseract sometimes returns multiple chars!\n  }\n\n  /** @inheritDoc */\n  public async destruct() {\n    this.worker.terminate();\n  }\n}\n","export type Point = [number, number];\n\ntype Rectangle = {\n  x: number;\n  y: number;\n  width: number;\n  height: number;\n};\n\nexport const distance = ([x1, y1]: Point, [x2, y2]: Point): number =>\n  ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** (1 / 2);\n\nexport const closest = (reference: Point, points: Point[]): Point => {\n  const distances = points.map(point => distance(reference, point));\n  let closestDistance = distances[0];\n\n  return points.reduce((closestPoint, point, i) => {\n    if (distances[i] < closestDistance) {\n      closestDistance = distances[i];\n      return point;\n    }\n    return closestPoint;\n  });\n};\n\nexport const measureSides = (coords: Point[]): number[] =>\n  coords.map((coord, i) => distance(coord, coords[i < coords.length - 1 ? i + 1 : 0]));\n\nexport const isPointInsideRect = (point: Point, rect: Rectangle) =>\n  point[0] >= rect.x &&\n  point[1] >= rect.y &&\n  point[0] <= rect.x + rect.width &&\n  point[0] <= rect.y + rect.height;\n","import { closest, isPointInsideRect, measureSides, Point } from '../../util/geometry';\n\n/** {@link https://docs.opencv.org/3.4/dc/dcf/tutorial_js_contour_features.html} */\nconst BOX_DETECTION_THRESHOLD = 0.01;\nconst SQUARE_SHAPE_THRESHOLD = 0.7;\nconst MIN_CHAR_AREA = 0.08;\nconst MAX_CHAR_AREA = 0.8;\nconst MIN_CHAR_ASPECT_RATIO = 0.2;\nconst MAX_CHAR_ASPECT_RATIO = 1.6;\n/** The average lightness threshold below which a cell is assumed empty. */\nconst CELL_EMPTY_THRESHOLD = 230;\nconst CHAR_PADDING = 0.05;\n\n/**\n * Because contours are just a list of numbers, e.g. [x1, y1, x2, y2, x3, y3...].\n */\nexport const getContourPathCoords = (contour: cv.Mat): Point[] => {\n  const pointVector = Array.from(contour.data32S);\n  const coords = Array(4);\n  for (let i = 0; i < 4; i++) coords[i] = pointVector.slice(i * 2, i * 2 + 2);\n\n  return coords;\n};\n\n/**\n * Simplifies the shape, reducing its number of sides.\n */\nexport const simplifyContour = (contour: cv.Mat): cv.Mat => {\n  const simplified = new cv.Mat();\n  const epsilon = BOX_DETECTION_THRESHOLD * cv.arcLength(contour, true);\n\n  cv.approxPolyDP(contour, simplified, epsilon, true);\n  return simplified;\n};\n\n/**\n * Returns true if the contour resembles a square (allowing for varied perspective angles and\n * rotation).\n *\n * @param contour\n * @param container The contour's container, to be used as a size reference.\n * @param minSize   The minimum size of the square (relative to container).\n * @param maxSize   The maximum size of the square (relative to container).\n */\nexport const isContourSquarish = (\n  contour: cv.Mat,\n  container?: cv.Mat,\n  minSize = 0,\n  maxSize = 1\n): boolean => {\n  // If we don't have 4 sides, then it's definitely not a square!\n  if (contour.size().height !== 4) return false;\n  // If there are no size constraints to apply...\n  if (!container) return true;\n\n  // Take the smaller of both sides, to allow for wide aspect ratio sources.\n  const minArea = Math.min(container.rows, container.cols) ** 2 * minSize;\n  const sizeLimit = Math.max(container.rows, container.cols) * maxSize;\n\n  // TODO: Tweak min-area threshold so that the 'design-3.jpg' test passes.\n  if (cv.contourArea(contour) >= minArea) {\n    const coords = getContourPathCoords(contour);\n\n    // Check that all sides are within ~70% of the longest side.\n    const sortedLengths = measureSides(coords).sort();\n    const longest = sortedLengths.pop();\n    if (!longest) return false;\n\n    return (\n      longest < sizeLimit &&\n      sortedLengths.every(length => length > SQUARE_SHAPE_THRESHOLD * longest)\n    );\n  }\n\n  return false;\n};\n\nexport const cropAndFlatten = (src: cv.Mat, rectangleContour: cv.Mat): cv.Mat => {\n  const [sourceWidth, sourceHeight] = [src.cols, src.rows];\n\n  // Find the corners of the contour (this won't work if the grid is too close to 45°).\n  const contourCoords = getContourPathCoords(rectangleContour);\n  const topLeft = closest([0, 0], contourCoords);\n  const topRight = closest([sourceWidth, 0], contourCoords);\n  const bottomLeft = closest([0, sourceHeight], contourCoords);\n  const bottomRight = closest([sourceWidth, sourceHeight], contourCoords);\n\n  // Choose the smallest width and side, for the cropped dimensions.\n  const newWidth = Math.min(topRight[0] - topLeft[0], bottomRight[0] - bottomLeft[0]);\n  const newHeight = Math.min(bottomLeft[1] - topLeft[1], bottomRight[1] - topRight[1]);\n  const flattened = cv.Mat.zeros(newWidth, newHeight, cv.CV_8UC3);\n  const size = new cv.Size(newWidth, newHeight);\n\n  // Produce a transformation matrix and apply it to the warp\n  // see: https://docs.opencv.org/3.4/dd/d52/tutorial_js_geometric_transformations.html\n  const srcTri = cv.matFromArray(4, 1, cv.CV_32FC2, [\n    ...topLeft,\n    ...topRight,\n    ...bottomRight,\n    ...bottomLeft,\n  ]);\n  const dstTri = cv.matFromArray(4, 1, cv.CV_32FC2, [\n    0,\n    0,\n    newWidth,\n    0,\n    newWidth,\n    newHeight,\n    0,\n    newHeight,\n  ]);\n  const transformMatrix = cv.getPerspectiveTransform(srcTri, dstTri);\n  cv.warpPerspective(src, flattened, transformMatrix, size, cv.INTER_LINEAR, cv.BORDER_CONSTANT);\n\n  transformMatrix.delete();\n  srcTri.delete();\n  dstTri.delete();\n\n  return flattened;\n};\n\nexport const split = (src: cv.Mat, rows: number, columns: number): cv.Mat[][] => {\n  const squares: cv.Mat[][] = new Array(rows);\n  const squareWidth = src.cols / columns;\n  const squareHeight = src.rows / rows;\n\n  for (let r = 0; r < rows; r++) {\n    squares[r] = new Array(columns);\n    for (let c = 0; c < columns; c++) {\n      const x = c * squareWidth;\n      const y = r * squareHeight;\n      // @ts-ignore\n      const crop = new cv.Rect(x, y, squareWidth, squareHeight);\n      squares[r][c] = src.roi(crop);\n    }\n  }\n\n  return squares;\n};\n\nexport const isEmpty = (src: cv.Mat) => {\n  const mean = new cv.Mat(1, 4, cv.CV_64F);\n  const stdDev = new cv.Mat(1, 4, cv.CV_64F);\n  cv.meanStdDev(src, mean, stdDev);\n\n  // @ts-ignore -- TODO Add missing CV type definitions, to avoid @ts-ignores\n  return mean.doubleAt(0, 0) >= CELL_EMPTY_THRESHOLD;\n};\n\n/**\n * Tesseract is notoriously bad at extracting text from table cells; so we need help it out, by\n * cropping the cell's contents to remove any edges (which can be mistaken for characters).\n *\n * @todo Move to SudokuScanner?\n */\nexport const cropCellBorders = (src: cv.Mat, binary: cv.Mat): cv.Mat | null => {\n  const cellCenter = [Math.round(binary.rows / 2), Math.round(binary.cols / 2)] as Point;\n  const cellArea = binary.rows * binary.cols;\n  const minArea = MIN_CHAR_AREA * cellArea;\n  const maxArea = MAX_CHAR_AREA * cellArea;\n  const contours = new cv.MatVector();\n  const hierarchy = new cv.Mat();\n\n  cv.findContours(binary, contours, hierarchy, cv.RETR_TREE, cv.CHAIN_APPROX_SIMPLE);\n  hierarchy.delete();\n\n  let largestArea = 0;\n  let largestRect = null;\n\n  for (let i = 0; i < contours.size(); i++) {\n    const contour = contours.get(i);\n    const rect = cv.boundingRect(contour);\n    const area = rect.width * rect.height;\n    const shapeRatio = rect.width / rect.height;\n\n    if (\n      area > minArea &&\n      area < maxArea &&\n      shapeRatio > MIN_CHAR_ASPECT_RATIO &&\n      shapeRatio < MAX_CHAR_ASPECT_RATIO &&\n      isPointInsideRect(cellCenter, rect) &&\n      area > largestArea\n    ) {\n      largestArea = area;\n      largestRect = rect;\n    }\n    contour.delete();\n  }\n\n  if (largestRect !== null) {\n    // OCR really is expensive, so anything we can do before it to eliminate empty cells, generally\n    // saves a lot of work.\n    const binaryCellContents = binary.roi(largestRect);\n    const isCellEmpty = isEmpty(binaryCellContents);\n    binaryCellContents.delete();\n\n    if (!isCellEmpty) {\n      // Padding the contents helps OCR.\n      const padding = Math.round(CHAR_PADDING * cellArea ** (1 / 2));\n\n      // TODO: Explore \"column walking\" method, to identify true upper bounds\n      //      (count at least ~5% black pixels in row, to disambiguate noise?)\n      largestRect.x = Math.max(largestRect.x - padding, 0);\n      largestRect.y = Math.max(largestRect.y - padding, 0);\n\n      // TODO: Pad tall-thin characters' width a bit more?\n      largestRect.width = Math.min(largestRect.width + 2 * padding, src.cols - largestRect.x);\n      largestRect.height = Math.min(largestRect.height + 2 * padding, src.rows - largestRect.y);\n\n      contours.delete();\n      return src.roi(largestRect);\n    }\n  }\n  contours.delete();\n  return null;\n};\n","import SudokuScannerInterface, { SudokuScannerConfig } from '../../types/interfaces/SudokuScanner';\nimport {\n  cropAndFlatten,\n  cropCellBorders,\n  isContourSquarish,\n  simplifyContour,\n  split,\n} from '../lib/cv';\n\n/**\n * Locates and extracts Sudoku puzzles from a supplied image.\n */\nexport default class SudokuScanner implements SudokuScannerInterface {\n  /** @inheritDoc */\n  protected readonly config: SudokuScannerConfig = {\n    rows: 9,\n    columns: 9,\n    preprocess: {\n      blurRadius: 11,\n      thresholdBlur: 5,\n      thresholdNorm: 2,\n    },\n    minSize: 0.25,\n    maxSize: 0.99,\n  };\n\n  /** The original, unmodified copy we will keep; so that we can later return a clean image. */\n  protected original: cv.Mat;\n  /** The source image, which will be modified for image analysis.  */\n  protected source: cv.Mat;\n  /** The processed versions of the image (undefined, if scan() hasn't been called yet).  */\n  protected processed?: {\n    /** A cropped version of the original image (useful for rendering in a UI). */\n    colour: cv.Mat;\n    /** A black & white copy, to avoid having to redo the image processing in subsequent stages. */\n    binary: cv.Mat;\n  } | null;\n\n  /**\n   * Loads the image to be scanned and applies custom config values, if supplied.\n   */\n  constructor(source: HTMLCanvasElement | ImageData, config?: Partial<SudokuScannerConfig>) {\n    if (!cv) throw new Error('OpenCV must be loaded!');\n\n    this.original =\n      source.constructor.name === 'ImageData' ? cv.matFromImageData(source) : cv.imread(source);\n    this.source = this.original.clone();\n    this.config = { ...this.config, ...config };\n  }\n\n  /** @inheritDoc */\n  public extractSudokuImage(outputCanvas?: HTMLCanvasElement): boolean {\n    // TODO: Check if image is too blurry (see: https://github.com/justadudewhohacks/opencv4nodejs/issues/448)\n    this.preprocessImage();\n    const largestSquare = this.findLargestSquare();\n\n    if (largestSquare !== null) {\n      this.processed = {\n        colour: cropAndFlatten(this.original, largestSquare),\n        binary: cropAndFlatten(this.source, largestSquare),\n      };\n\n      largestSquare.delete();\n      this.original.delete();\n      this.source.delete();\n\n      outputCanvas && cv.imshow(outputCanvas, this.processed.colour);\n      return true;\n    }\n\n    this.processed = null;\n    return false;\n  }\n\n  /** @inheritDoc */\n  public extractDigits(): (HTMLCanvasElement | null)[][] | null {\n    // If we didn't find a Sudoku, then we won't find any digits...\n    if (this.processed === null) return null;\n\n    // If we haven't scanned the image for Sudokus yet, we need to...\n    if (this.processed === undefined) {\n      this.extractSudokuImage();\n      return this.extractDigits();\n    }\n\n    const originalCells = split(this.processed.colour, this.config.rows, this.config.columns);\n    const binaryCells = split(this.processed.binary, this.config.rows, this.config.columns);\n    const grid: (HTMLCanvasElement | null)[][] = [];\n\n    for (let r = 0; r < this.config.rows; r++) {\n      const row = [];\n\n      for (let c = 0; c < this.config.columns; c++) {\n        const colourCell = originalCells[r][c];\n        const binaryCell = binaryCells[r][c];\n        const digitMat = cropCellBorders(colourCell, binaryCell);\n\n        if (digitMat) {\n          const canvas = document.createElement('canvas');\n          row.push(canvas);\n          cv.imshow(canvas, digitMat);\n\n          digitMat.delete();\n        } else row.push(null);\n\n        colourCell.delete();\n        binaryCell.delete();\n      }\n\n      grid.push(row);\n    }\n\n    return grid;\n  }\n\n  /** @inheritDoc */\n  public destruct(): void {\n    // If the image has been processed, then the this.original and this.source matrices have already\n    // been deleted.\n    if (this.processed) {\n      this.processed.colour.delete();\n      this.processed.binary.delete();\n    } else {\n      this.original.delete();\n      this.source.delete();\n    }\n  }\n\n  /**\n   * Applies image thresholding, to make the source image as close to black & white \"line art\" as\n   * possible (i.e. with the goal of finding contiguous lines, with minimal noise).\n   */\n  protected preprocessImage(): void {\n    const { blurRadius, thresholdBlur, thresholdNorm } = this.config.preprocess;\n\n    // Grayscale, to help line-identification.\n    cv.cvtColor(this.source, this.source, cv.COLOR_RGBA2GRAY, 0);\n    // Blur, to smooth out noise.\n    const blurKernel = new cv.Size(blurRadius, blurRadius);\n    cv.GaussianBlur(this.source, this.source, blurKernel, 0, 0, cv.BORDER_DEFAULT);\n    // Convert to black & white.\n    cv.adaptiveThreshold(\n      this.source,\n      this.source,\n      255, // black\n      cv.ADAPTIVE_THRESH_MEAN_C,\n      cv.THRESH_BINARY,\n      thresholdBlur,\n      thresholdNorm\n    );\n  }\n\n  /**\n   * Finds the contour (shape, in OpenCV) surrounding the largest Sudoku-like square in the source\n   * image.\n   */\n  protected findLargestSquare(): cv.Mat | null {\n    const contours = new cv.MatVector();\n    const hierarchy = new cv.Mat();\n\n    cv.findContours(this.source, contours, hierarchy, cv.RETR_TREE, cv.CHAIN_APPROX_SIMPLE);\n\n    let largestArea = 0;\n    let largestSquare = null;\n\n    for (let i = 0; i < contours.size(); i++) {\n      const contour = contours.get(i);\n      const simplified = simplifyContour(contour);\n\n      // TODO: Add additional constraints, e.g.parallel Hough lines, to reduce false positives?\n      if (isContourSquarish(simplified, this.source, this.config.minSize, this.config.maxSize)) {\n        const area = cv.contourArea(simplified);\n        if (area > largestArea) {\n          largestArea = area;\n          largestSquare = simplified.clone();\n        }\n      }\n      contour.delete();\n      simplified.delete();\n    }\n\n    contours.delete();\n    hierarchy.delete();\n\n    return largestSquare;\n  }\n}\n","interface Resolution {\n  width: number;\n  height: number;\n}\n\n/**\n * Used for getting the best-possible camera and configuration from `MediaDevices.getUserMedia()`.\n */\nconst idealCameraConstraints = {\n  width: { ideal: 4096 },\n  height: { ideal: 2160 },\n  facingMode: { ideal: 'environment' },\n  focusMode: { ideal: 'continuous' },\n  whiteBalance: { ideal: 'continuous' },\n  exposureMode: { ideal: 'continuous' },\n};\n\n/**\n * Attempts to find the device's main, telephoto, back-facing camera.\n */\nexport const identifyPrimaryCamera = async (): Promise<MediaDeviceInfo | null> => {\n  const inputDevices = await navigator.mediaDevices.enumerateDevices();\n  const cameras = inputDevices.filter(device => device.kind === 'videoinput');\n\n  if (!cameras.length) throw new Error('No camera found.');\n\n  const backFacingCameras = cameras.filter(camera => camera.label.includes('facing back'));\n\n  // For some reason, on phones with multiple cameras, the last one is usually the main one...\n  return backFacingCameras.length ? backFacingCameras[backFacingCameras.length - 1] : null;\n};\n\n/**\n *  Loads video stream into the supplied <video /> element.\n */\nexport const loadCameraStream = async (videoElement: HTMLVideoElement, dimensions?: Resolution) => {\n  const camera = await identifyPrimaryCamera();\n  const constraints = {\n    video: {\n      ...idealCameraConstraints,\n      // Fall back to the OS-selected camera, if our heuristic can't choose one.\n      deviceId: camera?.deviceId ? camera.deviceId : undefined,\n      ...(dimensions && {\n        width: { ideal: dimensions.width },\n        height: { ideal: dimensions.height },\n      }),\n    },\n    audio: false,\n  };\n\n  videoElement.srcObject = await navigator.mediaDevices.getUserMedia(constraints);\n  await videoElement.play();\n};\n\nexport const getFrame = (video: HTMLVideoElement): ImageData | null => {\n  // TODO: See if if it's more efficient to reuse the same frame buffer.\n  const buffer = document.createElement('canvas');\n  buffer.width = video.videoWidth;\n  buffer.height = video.videoHeight;\n  const ctx = buffer.getContext('2d');\n  if (!ctx) return null;\n\n  ctx.drawImage(video, 0, 0);\n  return ctx.getImageData(0, 0, buffer.width, buffer.height);\n};\n\n/**\n * Ends any streams associated with the <video />, so that the user's camera light turns off.\n */\nexport const turnOffCamera = (videoElement: HTMLVideoElement) => {\n  const stream = videoElement.srcObject as MediaStream;\n  stream.getVideoTracks()[0].stop();\n};\n","import { useCallback, useEffect, useRef } from 'react';\n\nimport { SudokuScanner } from '../services';\nimport DigitExtractor from '../services/DigitExtractor/DigitExtractor';\nimport { getFrame, loadCameraStream, turnOffCamera } from '../util/camera';\n\nexport default function SudokuSolver() {\n  const videoRef = useRef<HTMLVideoElement>(null);\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n  const streamRef = useRef(0);\n\n  const processStream = useCallback((input: HTMLVideoElement, output: HTMLCanvasElement) => {\n    const frame = getFrame(input);\n\n    if (frame && canvasRef.current) {\n      const scanner = new SudokuScanner(frame);\n      scanner.extractSudokuImage(canvasRef.current);\n      scanner.destruct();\n    }\n\n    streamRef.current = requestAnimationFrame(() => processStream(input, output));\n  }, []);\n\n  useEffect(() => {\n    if (!videoRef.current || !canvasRef.current) return () => {};\n    const video = videoRef.current;\n    const canvas = canvasRef.current;\n    const init = async () => {\n      // TODO: Turn off camera on tab change & test stop/starting robustness\n      await loadCameraStream(video, { width: 500, height: 500 });\n      processStream(video, canvas);\n    };\n\n    init();\n    (async () => {\n      const extractor = new DigitExtractor();\n      await extractor.load();\n      const digit = await extractor.extractSingle(`7.png`);\n\n      extractor.destruct();\n      // eslint-disable-next-line no-console\n      console.log('extracted', digit);\n    })();\n\n    return () => {\n      cancelAnimationFrame(streamRef.current);\n      turnOffCamera(video);\n    };\n  }, [processStream]);\n\n  return (\n    <>\n      <h1>🧮 Sudoku Solver</h1>\n      <video ref={videoRef} muted playsInline />\n      <canvas ref={canvasRef} />\n      <table id=\"grid1\" />\n    </>\n  );\n}\n","import './App.scss';\n\nimport { OpenCvProvider } from 'opencv-react';\nimport { useState } from 'react';\n\nimport SudokuSolver from './components';\n\nexport default function App() {\n  const [loading, setLoading] = useState(true);\n\n  // TODO: Add Error handling & browser feature checks\n\n  return (\n    <>\n      <button\n        style={{ position: 'fixed', top: '10px', left: '10px' }}\n        onClick={() => setLoading(!loading)}\n        type=\"button\"\n      >\n        {loading ? 'mount' : 'unmout'}\n      </button>\n      <OpenCvProvider\n        onLoad={() => setLoading(false)}\n        openCvPath={`${process.env.PUBLIC_URL}/opencv.js`}\n      >\n        {loading ? <i>Loading...</i> : <SudokuSolver />}\n      </OpenCvProvider>\n    </>\n  );\n}\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://cra.link/PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(/^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/)\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL || '', window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://cra.link/PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://cra.link/PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log('No internet connection found. App is running in offline mode.');\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import './index.scss';\n\nimport React from 'react';\nimport ReactDOM from 'react-dom';\n\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\nimport * as serviceWorkerRegistration from './serviceWorkerRegistration';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://cra.link/PWA\nserviceWorkerRegistration.unregister();\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}