{"version":3,"sources":["components/Animations/Ellipsis.module.scss","components/SudokuSolver.module.scss","components/SudokuScanner.module.scss","services/TextReader/TextReader.ts","App.module.scss","components/Camera.module.scss","components/Overlay.module.scss","components/Animations/LoadingBlocks.module.scss","components/Camera.tsx","util/camera.ts","services/SudokuSolver/SudokuSolver.ts","util/browser.ts","util/geometry.ts","services/lib/cv.ts","services/SudokuScanner/SudokuScanner.ts","hooks/useScanner.ts","components/Animations/Ellipsis.tsx","components/Animations/LoadingBlocks.tsx","components/SudokuScanner.tsx","hooks/useReader.ts","components/SudokuSolver.tsx","components/Overlay.tsx","App.tsx","reportWebVitals.ts","serviceWorkerRegistration.ts","index.tsx"],"names":["module","exports","TextReader","config","scheduler","language","threadCount","whitelist","single","getTesseractConfig","scriptDir","process","tesseractConfig","user_defined_dpi","tessedit_ocr_engine_mode","tessedit_pageseg_mode","undefined","tessedit_char_whitelist","workerConfig","isNode","langPath","path","join","__dirname","cacheMethod","gzip","workerPath","corePath","this","createScheduler","addThread","a","worker","createWorker","load","loadLanguage","initialize","setParameters","addWorker","Promise","allSettled","Array","fill","map","imageSource","addJob","text","data","slice","length","terminate","CameraStatus","idealCameraConstraints","width","ideal","height","facingMode","focusMode","whiteBalance","exposureMode","identifyPrimaryCamera","navigator","mediaDevices","enumerateDevices","inputDevices","cameras","filter","device","kind","Error","backFacingCameras","camera","label","includes","turnOnCamera","videoElement","dimensions","constraints","video","deviceId","audio","getUserMedia","srcObject","play","Camera","forwardRef","ref","onStatusUpdate","useEffect","current","catch","name","Denied","Unavailable","getVideoTracks","stop","className","styles","onLoadedMetadata","Active","onSuspend","playsInline","muted","SudokuSolver","grid","possibleDigits","blockWidth","blockHeight","Math","sqrt","buildPossibleDigitsMatrix","eliminateImpossibleDigits","autofillInferredValues","row","rowSet","Set","col","digit","has","add","columnSet","blockRow","blockCol","validateBlock","rowOffset","colOffset","blockSet","digitRow","digitCol","floor","heightRatio","widthRatio","r","c","i","scanCellsBlock","from","rowIndex","cell","cellIndex","digitCell","delete","eliminateFromRow","eliminateFromColumn","eliminateFromBlock","size","values","onlyPossibleValue","lastRow","lastCol","firstCol","n","validateCell","solve","browser","detect","scriptTimeout","parseFloat","loadScript","url","timeout","script","document","createElement","defer","startsWith","src","body","appendChild","resolve","reject","timeoutId","window","setTimeout","addEventListener","clearTimeout","loadMobileConsole","eruda","init","distance","x1","y1","x2","y2","closest","reference","points","distances","point","closestDistance","reduce","closestPoint","measureSides","coords","coord","isPointInsideRect","rect","x","y","getContourPathCoords","contour","pointVector","data32S","simplifyContour","simplified","cv","Mat","epsilon","arcLength","approxPolyDP","isContourSquarish","container","minSize","maxSize","minArea","min","rows","cols","sizeLimit","max","contourArea","sortedLengths","sort","longest","pop","every","cropAndFlatten","rectangleContour","sourceWidth","sourceHeight","contourCoords","topLeft","topRight","bottomLeft","bottomRight","newWidth","newHeight","flattened","zeros","CV_8UC3","Size","srcTri","matFromArray","CV_32FC2","dstTri","transformMatrix","getPerspectiveTransform","warpPerspective","INTER_LINEAR","BORDER_CONSTANT","split","columns","squares","squareWidth","squareHeight","crop","Rect","roi","cropCellBorders","binary","cellCenter","round","cellArea","maxArea","contours","MatVector","hierarchy","findContours","RETR_TREE","CHAIN_APPROX_SIMPLE","largestArea","largestRect","get","boundingRect","area","shapeRatio","binaryCellContents","isCellEmpty","mean","CV_64F","stdDev","meanStdDev","doubleAt","isEmpty","padding","SudokuScanner","source","preprocess","blurRadius","thresholdBlur","thresholdNorm","blurThreshold","original","processed","constructor","matFromImageData","imread","clone","outputCanvas","threshold","dst","standardDeviation","cvtColor","COLOR_RGB2GRAY","Laplacian","BORDER_DEFAULT","variance","data64F","isBlurry","preprocessImage","largestSquare","findLargestSquare","colour","imshow","extractSudokuImage","extractDigits","originalCells","binaryCells","colourCell","binaryCell","digitMat","canvas","push","COLOR_RGBA2GRAY","blurKernel","GaussianBlur","adaptiveThreshold","ADAPTIVE_THRESH_MEAN_C","THRESH_BINARY","timeLimit","buffer","getFrame","mask","getBoundingClientRect","displayWidth","displayHeight","cover","videoWidth","videoHeight","scaledWidth","scaledHeight","cropX","cropY","scale","videoMask","offsetLeft","offsetTop","offsetWidth","offsetHeight","ctx","getContext","drawImage","getImageData","Ellipsis","one","two","three","LoadingBlocks","loadingBlocks","block1","block2","block3","block4","block5","block6","block7","block8","block9","onFound","scanHz","canvasRef","useRef","output","useState","scannerLoaded","setScannerLoaded","digitImages","setDigitImages","scanSource","useCallback","start","Date","now","found","frame","scanner","SudokuScannerService","destruct","timeTaken","loadDependencies","then","useScanner","readerLoaded","setReaderLoaded","sudoku","setSudoku","digitReader","useMemo","readPendingDigits","all","parseInt","read","useReader","loadingMessage","sudokuScanner","sudokuSolver","SudokuSolverService","structuredClone","solved","isValid","key","error","Overlay","corners","overlay","role","corner","top","left","right","bottom","App","Loading","cameraStatus","setCameraStatus","videoRef","app","type","onClick","href","target","rel","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","Boolean","location","hostname","match","ReactDOM","render","StrictMode","getElementById","search","os","style","serviceWorker","ready","registration","unregister","console","message"],"mappings":"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","file":"static/js/main.e2c8fdc1.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"one\":\"Ellipsis_one__zElG3\",\"ellipsis\":\"Ellipsis_ellipsis__3jNN6\",\"two\":\"Ellipsis_two__2xLtj\",\"three\":\"Ellipsis_three__3hdzz\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"app\":\"SudokuSolver_app__oOmwd\",\"sudokuSolver\":\"SudokuSolver_sudokuSolver__10dvD\",\"original\":\"SudokuSolver_original__3pmhz\",\"error\":\"SudokuSolver_error__aZ9ao\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"app\":\"SudokuScanner_app__39mV1\",\"sudokuScanner\":\"SudokuScanner_sudokuScanner__3ToCZ\",\"loadingMessage\":\"SudokuScanner_loadingMessage__1RgGF\"};","import isNode from 'detect-node';\nimport path from 'path';\nimport {\n  createScheduler,\n  createWorker,\n  ImageLike,\n  PSM,\n  RecognizeResult,\n  Scheduler,\n  WorkerOptions,\n  WorkerParams,\n} from 'tesseract.js';\n\nimport TextReaderInterface, { TextReaderConfig } from '../../types/interfaces/TextReader';\n\nexport default class TextReader implements TextReaderInterface {\n  protected readonly scheduler: Scheduler;\n  protected readonly language = 'eng';\n  protected readonly config: TextReaderConfig = {\n    /** 2 threads seems a good compromise on mobile devices */\n    threadCount: 2, // TODO: Dynamically determine optimal thread count.\n    whitelist: '',\n    single: false,\n  };\n\n  constructor(config?: Partial<TextReaderConfig>) {\n    this.config = { ...this.config, ...config };\n    this.scheduler = createScheduler();\n  }\n\n  /** @inheritDoc */\n  public async load(): Promise<void> {\n    const { workerConfig, tesseractConfig } = this.getTesseractConfig();\n    const addThread = async () => {\n      const worker = createWorker(workerConfig);\n\n      await worker.load();\n      await worker.loadLanguage(this.language);\n      await worker.initialize(this.language);\n      await worker.setParameters(tesseractConfig);\n\n      this.scheduler.addWorker(worker);\n    };\n\n    await Promise.allSettled(Array(this.config.threadCount).fill(0).map(addThread));\n  }\n\n  /** @inheritDoc */\n  public async read(imageSource: ImageLike): Promise<string> {\n    const {\n      data: { text },\n    } = (await this.scheduler.addJob('recognize', imageSource)) as RecognizeResult;\n\n    // Tesseract always appends a newline, and sometimes returns multiple chars in single-char mode!\n    return text.slice(0, this.config.single ? 1 : text.length - 1);\n  }\n\n  /** @inheritDoc */\n  public async destruct() {\n    await this.scheduler.terminate();\n  }\n\n  /**\n   * \"Translates\" our configuration into Tesseract's.\n   */\n  protected getTesseractConfig = () => {\n    const tesseractConfig: Partial<WorkerParams> = {\n      user_defined_dpi: '300',\n      tessedit_ocr_engine_mode: 2,\n      tessedit_pageseg_mode: this.config.single ? ('10' as PSM) : undefined,\n      tessedit_char_whitelist: this.config.whitelist || undefined,\n    };\n\n    // Configure Tesseract worker to not make external download requests...\n    const scriptDir = process.env.REACT_APP_PUBLIC_SCRIPT_DIR ?? '';\n    const workerConfig: Partial<WorkerOptions> = isNode\n      ? {\n          langPath: path.join(__dirname, '..', '..', '..', 'public', scriptDir, 'ocr'),\n          // It should be faster to cache the uncompressed lang data, although there seems to be no\n          // real difference in practice; so we may as well keep the repo smaller.\n          cacheMethod: 'none',\n          gzip: true,\n        }\n      : {\n          langPath: `${process.env.PUBLIC_URL}/${scriptDir}/ocr`,\n          workerPath: `${process.env.PUBLIC_URL}/${scriptDir}/ocr/worker.min.js`,\n          corePath: `${process.env.PUBLIC_URL}/${scriptDir}/ocr/tesseract-core.wasm.js`,\n        };\n\n    return { tesseractConfig, workerConfig };\n  };\n}\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"app\":\"App_app__2ziFi\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"camera\":\"Camera_camera__1ODM1\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"app\":\"Overlay_app__3lk76\",\"overlay\":\"Overlay_overlay__3vGmN\",\"corner\":\"Overlay_corner__1TZHo\",\"top\":\"Overlay_top__1gty1\",\"left\":\"Overlay_left__3L_DC\",\"right\":\"Overlay_right___Zrwb\",\"bottom\":\"Overlay_bottom__v5eaf\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"app\":\"LoadingBlocks_app__-G7ER\",\"loadingBlocks\":\"LoadingBlocks_loadingBlocks__WdlnC\",\"load\":\"LoadingBlocks_load__2vBzM\",\"block1\":\"LoadingBlocks_block1__3UdgJ\",\"block2\":\"LoadingBlocks_block2__2F5y7\",\"block3\":\"LoadingBlocks_block3__2dRof\",\"block4\":\"LoadingBlocks_block4__2bBin\",\"block5\":\"LoadingBlocks_block5__3LT2j\",\"block6\":\"LoadingBlocks_block6__1ZCCM\",\"block7\":\"LoadingBlocks_block7__3yVzZ\",\"block8\":\"LoadingBlocks_block8__1q1wE\",\"block9\":\"LoadingBlocks_block9__1MBjw\"};","import { forwardRef, MutableRefObject, useEffect } from 'react';\n\nimport { turnOffCamera, turnOnCamera } from '../util/camera';\nimport styles from './Camera.module.scss';\n\nexport enum CameraStatus {\n  Loading,\n  Active,\n  Denied,\n  Unavailable,\n}\n\n/**\n * Renders a video feed of the user's camera (if one is available, with permission granted).\n */\nconst Camera = forwardRef<HTMLVideoElement, Props>(({ onStatusUpdate }: Props, ref) => {\n  useEffect(() => {\n    const { current } = ref as MutableRefObject<HTMLVideoElement | null>;\n\n    if (!current) return () => {};\n\n    turnOnCamera(current).catch(({ name }) =>\n      onStatusUpdate(name === 'NotAllowedError' ? CameraStatus.Denied : CameraStatus.Unavailable)\n    );\n\n    return () => turnOffCamera(current);\n  }, [onStatusUpdate, ref]);\n\n  return (\n    <video\n      className={styles.camera}\n      ref={ref}\n      onLoadedMetadata={() => onStatusUpdate(CameraStatus.Active)}\n      onSuspend={() => onStatusUpdate(CameraStatus.Unavailable)}\n      playsInline\n      muted\n    />\n  );\n});\n\ntype Props = { onStatusUpdate(status: CameraStatus): void };\nexport default Camera;\n","interface Resolution {\n  width: number;\n  height: number;\n}\n\n/**\n * Used for getting the best-possible camera and configuration from `MediaDevices.getUserMedia()`.\n */\nconst idealCameraConstraints = {\n  width: { ideal: 2048 },\n  height: { ideal: 1080 },\n  facingMode: { ideal: 'environment' },\n  focusMode: { ideal: 'continuous' },\n  whiteBalance: { ideal: 'continuous' },\n  exposureMode: { ideal: 'continuous' },\n};\n\n/**\n * Attempts to find the device's main, telephoto, back-facing camera.\n */\nexport const identifyPrimaryCamera = async (): Promise<MediaDeviceInfo | null> => {\n  const inputDevices = await navigator.mediaDevices.enumerateDevices();\n  const cameras = inputDevices.filter(device => device.kind === 'videoinput');\n\n  if (!cameras.length) throw new Error('No camera found.');\n\n  const backFacingCameras = cameras.filter(camera => camera.label.includes('facing back'));\n\n  // For some reason, on phones with multiple cameras, the last one is usually the main one...\n  return backFacingCameras.length ? backFacingCameras[backFacingCameras.length - 1] : null;\n};\n\n/**\n *  Loads video stream into the supplied <video /> element.\n */\nexport const turnOnCamera = async (videoElement: HTMLVideoElement, dimensions?: Resolution) => {\n  const camera = await identifyPrimaryCamera();\n  const constraints = {\n    video: {\n      ...idealCameraConstraints,\n      // Fall back to the OS-selected camera, if our heuristic can't choose one.\n      deviceId: camera?.deviceId ? camera.deviceId : undefined,\n      ...(dimensions && {\n        width: { ideal: dimensions.width },\n        height: { ideal: dimensions.height },\n      }),\n    },\n    audio: false,\n  };\n\n  videoElement.srcObject = await navigator.mediaDevices.getUserMedia(constraints);\n  await videoElement.play();\n};\n\n/**\n * Ends any streams associated with the <video />, so that the user's camera light turns off.\n */\nexport const turnOffCamera = (videoElement: HTMLVideoElement) => {\n  const stream = videoElement.srcObject as MediaStream;\n  stream.getVideoTracks()[0].stop();\n};\n","import SudokuSolverInterface, {\n  PossibleDigitsMatrix,\n  Sudoku,\n} from '../../types/interfaces/SudokuSolver';\n\nconst EMPTY = 0;\n\nexport default class SudokuSolver implements SudokuSolverInterface {\n  protected grid: Sudoku;\n  protected possibleDigits: PossibleDigitsMatrix;\n  protected width: number;\n  protected height: number;\n  protected blockWidth: number;\n  protected blockHeight: number;\n\n  constructor(grid: Sudoku) {\n    this.grid = grid;\n    this.width = grid[0].length;\n    this.height = grid.length;\n    this.blockWidth = Math.sqrt(this.width);\n    this.blockHeight = Math.sqrt(this.height);\n    // TODO: See if using bitmasks is much faster than using sets... 🧐\n    this.possibleDigits = this.buildPossibleDigitsMatrix();\n\n    this.eliminateImpossibleDigits();\n    this.autofillInferredValues();\n  }\n\n  public isValid(): boolean {\n    const { grid, width, height, blockWidth, blockHeight } = this;\n\n    // Check rows\n    for (let row = 0; row < height; row++) {\n      const rowSet = new Set();\n\n      for (let col = 0; col < width; col++) {\n        const digit = grid[row][col];\n\n        if (digit) {\n          if (rowSet.has(digit)) return false;\n          rowSet.add(digit);\n        }\n      }\n    }\n\n    // Check columns\n    for (let col = 0; col < width; col++) {\n      const columnSet = new Set();\n\n      for (let row = 0; row < height; row++) {\n        const digit = grid[row][col];\n\n        if (digit) {\n          if (columnSet.has(digit)) return false;\n          columnSet.add(digit);\n        }\n      }\n    }\n\n    // Check blocks\n    for (let blockRow = 0; blockRow < height / blockHeight; blockRow++)\n      for (let blockCol = 0; blockCol < width / blockWidth; blockCol++)\n        if (!this.validateBlock(blockRow, blockCol)) return false;\n\n    return true;\n  }\n\n  /**\n   * Helper function for isValid() - this shouldn't be used to validate a specific cell's block,\n   * as there's no need to build a Set in that case (given that you only need to search for one\n   * digit).\n   */\n  protected validateBlock(blockRow: number, blockCol: number): boolean {\n    const { grid, blockWidth, blockHeight } = this;\n\n    const rowOffset = blockRow * blockHeight;\n    const colOffset = blockCol * blockWidth;\n    const blockSet = new Set();\n\n    for (let row = rowOffset; row < rowOffset + blockHeight; row++) {\n      for (let col = colOffset; col < colOffset + blockWidth; col++) {\n        const digit = grid[row][col];\n\n        if (digit) {\n          if (blockSet.has(digit)) return false;\n          blockSet.add(digit);\n        }\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * Returns true, if the specified digit exists elsewhere in its block.\n   * (This is a pretty big \"cycle-saver\", as it will sit in the innermost loop of the solve()\n   * method.)\n   */\n  protected scanCellsBlock(digit: number, digitRow: number, digitCol: number): boolean {\n    const blockRow = Math.floor(digitRow / this.blockHeight);\n    const blockCol = Math.floor(digitCol / this.blockWidth);\n    const heightRatio = this.height / this.blockHeight;\n    const widthRatio = this.width / this.blockWidth;\n\n    for (let r = 0; r < this.blockHeight; r++) {\n      const row = blockRow * heightRatio + r;\n      for (let c = 0; c < this.blockWidth; c++) {\n        const col = blockCol * widthRatio + c;\n        if (row !== digitRow && col !== digitCol && this.grid[row][col] === digit) return false;\n      }\n    }\n\n    return true;\n  }\n\n  protected validateCell(row: number, col: number): boolean {\n    const { grid, height } = this;\n    const digit = grid[row][col];\n\n    for (let i = 0; i < height; i++) {\n      if (i !== col && grid[row][i] === digit) return false;\n      if (i !== row && grid[i][col] === digit) return false;\n    }\n\n    return this.scanCellsBlock(digit, row, col);\n  }\n\n  protected buildPossibleDigitsMatrix(): PossibleDigitsMatrix {\n    return Array.from({ length: this.height }, (row, rowIndex) =>\n      Array.from({ length: this.width }, (cell, cellIndex) => {\n        const possibleDigits = this.grid[rowIndex][cellIndex]\n          ? [this.grid[rowIndex][cellIndex]]\n          : [1, 2, 3, 4, 5, 6, 7, 8, 9];\n        return new Set(possibleDigits);\n      })\n    );\n  }\n\n  protected eliminateFromRow(digit: number, row: number, digitCell: number): void {\n    for (let col = 0; col < this.width; col++)\n      // Skip the cell we're using as a reference point.\n      if (col !== digitCell) this.possibleDigits[row][col].delete(digit);\n  }\n\n  protected eliminateFromColumn(digit: number, col: number, digitRow: number): void {\n    for (let row = 0; row < this.height; row++)\n      // Skip the cell we're using as a reference point.\n      if (row !== digitRow) this.possibleDigits[row][col].delete(digit);\n  }\n\n  protected eliminateFromBlock(digit: number, digitRow: number, digitCol: number): void {\n    const blockRow = Math.floor(digitRow / this.blockHeight);\n    const blockCol = Math.floor(digitCol / this.blockWidth);\n    const heightRatio = this.height / this.blockHeight;\n    const widthRatio = this.width / this.blockWidth;\n\n    for (let r = 0; r < this.blockHeight; r++) {\n      const row = blockRow * heightRatio + r;\n      for (let c = 0; c < this.blockWidth; c++) {\n        const col = blockCol * widthRatio + c;\n        if (row !== digitRow && col !== digitCol) this.possibleDigits[row][col].delete(digit);\n      }\n    }\n  }\n\n  protected eliminateImpossibleDigits(): void {\n    for (let row = 0; row < this.height; row++) {\n      for (let col = 0; col < this.width; col++) {\n        const digit = this.grid[row][col];\n\n        this.eliminateFromRow(digit, row, col);\n        this.eliminateFromColumn(digit, col, row);\n        this.eliminateFromBlock(digit, row, col);\n      }\n    }\n  }\n\n  /**\n   * Autofill the grid, using possibleDigitsMatrix values (where the corresponding set has only one\n   * value).\n   */\n  protected autofillInferredValues(): void {\n    for (let row = 0; row < this.height; row++)\n      for (let col = 0; col < this.width; col++)\n        if (this.possibleDigits[row][col].size === 1) {\n          const [onlyPossibleValue] = Array.from(this.possibleDigits[row][col].values());\n          this.grid[row][col] = onlyPossibleValue;\n        }\n  }\n\n  public solve(lastRow = 0, lastCol = 0): Sudoku | null {\n    const { grid, width, height } = this;\n    let firstCol = true;\n\n    for (let row = lastRow; row < height; row++) {\n      for (let col = firstCol ? lastCol : 0; col < width; col++) {\n        if (grid[row][col] === EMPTY) {\n          // If the cell is empty, try filling it with each possible number\n          for (const n of Array.from(this.possibleDigits[row][col])) {\n            grid[row][col] = n;\n\n            // If this number is valid in the cell, continue exploring this \"path\" with a DFS and\n            // return the grid if it solves.\n            if (this.validateCell(row, col) && this.solve(row, col + 1)) return grid;\n          }\n\n          // If we couldn't find a valid number for the cell, then we need to stop exploring this\n          // path and backtrack; by resetting the cell to \"empty\".\n          grid[row][col] = EMPTY;\n          return null;\n        }\n      }\n\n      firstCol = false;\n    }\n\n    return grid;\n  }\n}\n","import { detect } from 'detect-browser';\n\nexport const browser = detect();\n\nconst scriptTimeout = parseFloat(process.env.REACT_APP_SCRIPT_LOAD_TIMEOUT ?? '') || 10000;\n\n/**\n * Some scripts aren't available on npm, as modules or are simply too big to be bundled, in a\n * browser context; so this function will load them \"the old fashioned way\", via a script element.\n *\n * @param url     The url of the script to load (can be relative or absolute).\n * @param timeout The max amount of time the script can take to load, before throwing an Error.\n */\nexport const loadScript = async (url: string, timeout = scriptTimeout): Promise<void> => {\n  const script = document.createElement('script');\n  script.defer = true;\n\n  if (url.startsWith('http')) script.src = url;\n  else script.src = `${process.env.PUBLIC_URL}/${process.env.REACT_APP_PUBLIC_SCRIPT_DIR}/${url}`;\n\n  document.body.appendChild(script);\n\n  return new Promise((resolve, reject): void => {\n    const timeoutId = window.setTimeout(\n      () => reject(new Error(`${url} failed to load in time`)),\n      timeout\n    );\n\n    script.addEventListener('load', () => {\n      window.clearTimeout(timeoutId);\n      resolve();\n    });\n  });\n};\n\n/**\n * Loads a mobile console that can be very helpful for debugging on mobile devices.\n * (Eruda's npm package unfortunately doesn't export a module, so we have to manually load it like\n * this.)\n */\nexport const loadMobileConsole = async (): Promise<void> => {\n  await loadScript('mobileConsole.js');\n  // @ts-ignore -- eruda will have been defined globally, by the script.\n  eruda.init();\n};\n\n/**\n * @see https://bugs.webkit.org/show_bug.cgi?id=141832\n */\nexport const fixViewportHeightInMobileSafari = (): void => {\n  browser?.os === 'iOS' &&\n    browser.name === 'ios' &&\n    window.addEventListener('resize', () => {\n      document.body.style.height = '100vh';\n    });\n};\n","export type Point = [number, number];\n\ntype Rectangle = {\n  x: number;\n  y: number;\n  width: number;\n  height: number;\n};\n\nexport const distance = ([x1, y1]: Point, [x2, y2]: Point): number =>\n  ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5;\n\nexport const closest = (reference: Point, points: Point[]): Point => {\n  const distances = points.map(point => distance(reference, point));\n  let closestDistance = distances[0];\n\n  return points.reduce((closestPoint, point, i) => {\n    if (distances[i] < closestDistance) {\n      closestDistance = distances[i];\n      return point;\n    }\n    return closestPoint;\n  });\n};\n\nexport const measureSides = (coords: Point[]): number[] =>\n  coords.map((coord, i) => distance(coord, coords[i < coords.length - 1 ? i + 1 : 0]));\n\nexport const isPointInsideRect = (point: Point, rect: Rectangle) =>\n  point[0] >= rect.x &&\n  point[1] >= rect.y &&\n  point[0] <= rect.x + rect.width &&\n  point[0] <= rect.y + rect.height;\n","import { closest, isPointInsideRect, measureSides, Point } from '../../util/geometry';\n\n/** {@link https://docs.opencv.org/3.4/dc/dcf/tutorial_js_contour_features.html} */\nconst BOX_DETECTION_THRESHOLD = 0.01;\nconst SQUARE_SHAPE_THRESHOLD = 0.7;\nconst MIN_CHAR_AREA = 0.08;\nconst MAX_CHAR_AREA = 0.8;\nconst MIN_CHAR_ASPECT_RATIO = 0.2;\nconst MAX_CHAR_ASPECT_RATIO = 1.6;\n/** The average lightness threshold below which a cell is assumed empty. */\nconst CELL_EMPTY_THRESHOLD = 230;\nconst CHAR_PADDING = 0.05;\n\n/**\n * Because contours are just a list of numbers, e.g. [x1, y1, x2, y2, x3, y3...].\n */\nexport const getContourPathCoords = (contour: cv.Mat): Point[] => {\n  const pointVector = Array.from(contour.data32S);\n  const coords = Array(4);\n  for (let i = 0; i < 4; i++) coords[i] = pointVector.slice(i * 2, i * 2 + 2);\n\n  return coords;\n};\n\n/**\n * Simplifies the shape, reducing its number of sides.\n */\nexport const simplifyContour = (contour: cv.Mat): cv.Mat => {\n  const simplified = new cv.Mat();\n  const epsilon = BOX_DETECTION_THRESHOLD * cv.arcLength(contour, true);\n\n  cv.approxPolyDP(contour, simplified, epsilon, true);\n  return simplified;\n};\n\n/**\n * Returns true if the contour resembles a square (allowing for varied perspective angles and\n * rotation).\n *\n * @param contour\n * @param container The contour's container, to be used as a size reference.\n * @param minSize   The minimum size of the square (relative to container).\n * @param maxSize   The maximum size of the square (relative to container).\n */\nexport const isContourSquarish = (\n  contour: cv.Mat,\n  container?: cv.Mat,\n  minSize = 0,\n  maxSize = 1\n): boolean => {\n  // If we don't have 4 sides, then it's definitely not a square!\n  if (contour.size().height !== 4) return false;\n  // If there are no size constraints to apply...\n  if (!container) return true;\n\n  // Take the smaller of both sides, to allow for wide aspect ratio sources.\n  const minArea = Math.min(container.rows, container.cols) ** 2 * minSize;\n  const sizeLimit = Math.max(container.rows, container.cols) * maxSize;\n\n  if (cv.contourArea(contour) >= minArea) {\n    const coords = getContourPathCoords(contour);\n\n    // Check that all sides are within ~70% of the longest side.\n    const sortedLengths = measureSides(coords).sort();\n    const longest = sortedLengths.pop();\n    if (!longest) return false;\n\n    return (\n      longest < sizeLimit &&\n      sortedLengths.every(length => length > SQUARE_SHAPE_THRESHOLD * longest)\n    );\n  }\n\n  return false;\n};\n\n/**\n * Determines if the image is blurry.\n *\n * @param src       Source image\n * @param threshold How sharp you want it to be: 100 = reasonably sharp, 500 = very sharp.\n */\nexport const isBlurry = (src: cv.Mat, threshold: number): boolean => {\n  // See: https://pyimagesearch.com/2015/09/07/blur-detection-with-opencv/\n  const dst = new cv.Mat();\n  const mean = new cv.Mat();\n  const standardDeviation = new cv.Mat();\n  const clone = src.clone();\n\n  cv.cvtColor(clone, clone, cv.COLOR_RGB2GRAY, 0);\n  cv.Laplacian(clone, dst, cv.CV_64F, 1, 1, 0, cv.BORDER_DEFAULT);\n  cv.meanStdDev(dst, mean, standardDeviation);\n\n  const variance = standardDeviation.data64F[0] ** 2;\n\n  clone.delete();\n  dst.delete();\n  mean.delete();\n  standardDeviation.delete();\n\n  return variance < threshold;\n};\n\nexport const cropAndFlatten = (src: cv.Mat, rectangleContour: cv.Mat): cv.Mat => {\n  const [sourceWidth, sourceHeight] = [src.cols, src.rows];\n\n  // Find the corners of the contour (this won't work if the grid is too close to 45°).\n  const contourCoords = getContourPathCoords(rectangleContour);\n  const topLeft = closest([0, 0], contourCoords);\n  const topRight = closest([sourceWidth, 0], contourCoords);\n  const bottomLeft = closest([0, sourceHeight], contourCoords);\n  const bottomRight = closest([sourceWidth, sourceHeight], contourCoords);\n\n  // Choose the smallest width and side, for the cropped dimensions.\n  const newWidth = Math.min(topRight[0] - topLeft[0], bottomRight[0] - bottomLeft[0]);\n  const newHeight = Math.min(bottomLeft[1] - topLeft[1], bottomRight[1] - topRight[1]);\n  const flattened = cv.Mat.zeros(newWidth, newHeight, cv.CV_8UC3);\n  const size = new cv.Size(newWidth, newHeight);\n\n  // Produce a transformation matrix and apply it to the warp\n  // see: https://docs.opencv.org/3.4/dd/d52/tutorial_js_geometric_transformations.html\n  const srcTri = cv.matFromArray(4, 1, cv.CV_32FC2, [\n    ...topLeft,\n    ...topRight,\n    ...bottomRight,\n    ...bottomLeft,\n  ]);\n  const dstTri = cv.matFromArray(4, 1, cv.CV_32FC2, [\n    0,\n    0,\n    newWidth,\n    0,\n    newWidth,\n    newHeight,\n    0,\n    newHeight,\n  ]);\n  const transformMatrix = cv.getPerspectiveTransform(srcTri, dstTri);\n  cv.warpPerspective(src, flattened, transformMatrix, size, cv.INTER_LINEAR, cv.BORDER_CONSTANT);\n\n  transformMatrix.delete();\n  srcTri.delete();\n  dstTri.delete();\n\n  return flattened;\n};\n\nexport const split = (src: cv.Mat, rows: number, columns: number): cv.Mat[][] => {\n  const squares: cv.Mat[][] = new Array(rows);\n  const squareWidth = src.cols / columns;\n  const squareHeight = src.rows / rows;\n\n  for (let r = 0; r < rows; r++) {\n    squares[r] = new Array(columns);\n    for (let c = 0; c < columns; c++) {\n      const x = c * squareWidth;\n      const y = r * squareHeight;\n      const crop = new cv.Rect(x, y, squareWidth, squareHeight);\n      squares[r][c] = src.roi(crop);\n    }\n  }\n\n  return squares;\n};\n\nexport const isEmpty = (src: cv.Mat) => {\n  const mean = new cv.Mat(1, 4, cv.CV_64F);\n  const stdDev = new cv.Mat(1, 4, cv.CV_64F);\n  cv.meanStdDev(src, mean, stdDev);\n\n  return mean.doubleAt(0, 0) >= CELL_EMPTY_THRESHOLD;\n};\n\n/**\n * Tesseract is notoriously bad at extracting text from table cells; so we need help it out, by\n * cropping the cell's contents to remove any edges (which can be mistaken for characters).\n */\nexport const cropCellBorders = (src: cv.Mat, binary: cv.Mat): cv.Mat | null => {\n  const cellCenter = [Math.round(binary.rows / 2), Math.round(binary.cols / 2)] as Point;\n  const cellArea = binary.rows * binary.cols;\n  const minArea = MIN_CHAR_AREA * cellArea;\n  const maxArea = MAX_CHAR_AREA * cellArea;\n  const contours = new cv.MatVector();\n  const hierarchy = new cv.Mat();\n\n  cv.findContours(binary, contours, hierarchy, cv.RETR_TREE, cv.CHAIN_APPROX_SIMPLE);\n  hierarchy.delete();\n\n  let largestArea = 0;\n  let largestRect = null;\n\n  for (let i = 0; i < contours.size(); i++) {\n    const contour = contours.get(i);\n    const rect = cv.boundingRect(contour);\n    const area = rect.width * rect.height;\n    const shapeRatio = rect.width / rect.height;\n\n    if (\n      area > minArea &&\n      area < maxArea &&\n      shapeRatio > MIN_CHAR_ASPECT_RATIO &&\n      shapeRatio < MAX_CHAR_ASPECT_RATIO &&\n      isPointInsideRect(cellCenter, rect) &&\n      area > largestArea\n    ) {\n      largestArea = area;\n      largestRect = rect;\n    }\n    contour.delete();\n  }\n\n  if (largestRect !== null) {\n    // OCR really is expensive, so anything we can do before it to eliminate empty cells, generally\n    // saves a lot of work.\n    const binaryCellContents = binary.roi(largestRect);\n    const isCellEmpty = isEmpty(binaryCellContents);\n    binaryCellContents.delete();\n\n    if (!isCellEmpty) {\n      // Padding the contents helps OCR.\n      const padding = Math.round(CHAR_PADDING * cellArea ** (1 / 2));\n\n      // TODO: Explore \"column walking\" method, to identify true upper bounds\n      //      (count at least ~5% black pixels in row, to disambiguate noise?)\n      largestRect.x = Math.max(largestRect.x - padding, 0);\n      largestRect.y = Math.max(largestRect.y - padding, 0);\n\n      // TODO: Pad tall-thin characters' width a bit more?\n      largestRect.width = Math.min(largestRect.width + 2 * padding, src.cols - largestRect.x);\n      largestRect.height = Math.min(largestRect.height + 2 * padding, src.rows - largestRect.y);\n\n      contours.delete();\n      return src.roi(largestRect);\n    }\n  }\n  contours.delete();\n  return null;\n};\n","import isNode from 'detect-node';\n\nimport SudokuScannerInterface, {\n  SudokuDigitImages,\n  SudokuScannerConfig,\n} from '../../types/interfaces/SudokuScanner';\nimport { loadScript } from '../../util/browser';\nimport {\n  cropAndFlatten,\n  cropCellBorders,\n  isBlurry,\n  isContourSquarish,\n  simplifyContour,\n  split,\n} from '../lib/cv';\n\n/**\n * Locates and extracts Sudoku puzzles from a supplied image.\n */\nexport default class SudokuScanner implements SudokuScannerInterface {\n  /** @inheritDoc */\n  protected readonly config: SudokuScannerConfig = {\n    rows: 9,\n    columns: 9,\n    preprocess: {\n      blurRadius: 11,\n      thresholdBlur: 5,\n      thresholdNorm: 2,\n    },\n    minSize: 0.25,\n    maxSize: 0.99,\n    blurThreshold: 500,\n  };\n\n  /** The original, unmodified copy we will keep; so that we can later return a clean image. */\n  protected original: cv.Mat;\n  /** The source image, which will be modified for image analysis.  */\n  protected source: cv.Mat;\n  /** The processed versions of the image (undefined, if scan() hasn't been called yet).  */\n  protected processed?: {\n    /** A cropped version of the original image (useful for rendering in a UI). */\n    colour: cv.Mat;\n    /** A black & white copy, to avoid having to redo the image processing in subsequent stages. */\n    binary: cv.Mat;\n  } | null;\n\n  /**\n   * Loads the image to be scanned and applies custom config values, if supplied.\n   */\n  constructor(source: HTMLCanvasElement | ImageData, config?: Partial<SudokuScannerConfig>) {\n    if (!cv) throw new Error('OpenCV must be loaded!');\n\n    this.original =\n      source.constructor.name === 'ImageData' ? cv.matFromImageData(source) : cv.imread(source);\n    this.source = this.original.clone();\n    this.config = { ...this.config, ...config };\n  }\n\n  /** @inheritDoc */\n  public extractSudokuImage(outputCanvas?: HTMLCanvasElement): boolean {\n    // TODO: Return an enum describing different error states (not found, too blurry, etc.)\n    if (isBlurry(this.source, this.config.blurThreshold)) return false;\n\n    this.preprocessImage();\n    const largestSquare = this.findLargestSquare();\n\n    if (largestSquare !== null) {\n      this.processed = {\n        colour: cropAndFlatten(this.original, largestSquare),\n        binary: cropAndFlatten(this.source, largestSquare),\n      };\n\n      largestSquare.delete();\n      this.original.delete();\n      this.source.delete();\n\n      outputCanvas && cv.imshow(outputCanvas, this.processed.colour);\n      return true;\n    }\n\n    this.processed = null;\n    return false;\n  }\n\n  /** @inheritDoc */\n  public extractDigits(): SudokuDigitImages | null {\n    // If we didn't find a Sudoku, then we won't find any digits...\n    if (this.processed === null) return null;\n\n    // If we haven't scanned the image for Sudokus yet, we need to...\n    if (this.processed === undefined) {\n      return this.extractSudokuImage() ? this.extractDigits() : null;\n    }\n\n    const originalCells = split(this.processed.colour, this.config.rows, this.config.columns);\n    const binaryCells = split(this.processed.binary, this.config.rows, this.config.columns);\n    const grid: (HTMLCanvasElement | null)[][] = [];\n\n    for (let r = 0; r < this.config.rows; r++) {\n      const row = [];\n\n      for (let c = 0; c < this.config.columns; c++) {\n        const colourCell = originalCells[r][c];\n        const binaryCell = binaryCells[r][c];\n        const digitMat = cropCellBorders(colourCell, binaryCell);\n\n        if (digitMat) {\n          const canvas = document.createElement('canvas');\n          row.push(canvas);\n          cv.imshow(canvas, digitMat);\n\n          digitMat.delete();\n        } else row.push(null);\n\n        colourCell.delete();\n        binaryCell.delete();\n      }\n\n      grid.push(row);\n    }\n\n    return grid;\n  }\n\n  /** @inheritDoc */\n  public destruct(): void {\n    // If the image has been processed, then the this.original and this.source matrices have already\n    // been deleted.\n    if (this.processed) {\n      this.processed.colour.delete();\n      this.processed.binary.delete();\n    } else {\n      this.original.delete();\n      this.source.delete();\n    }\n  }\n\n  /**\n   * Applies image thresholding, to make the source image as close to black & white \"line art\" as\n   * possible (i.e. with the goal of finding contiguous lines, with minimal noise).\n   */\n  protected preprocessImage(): void {\n    const { blurRadius, thresholdBlur, thresholdNorm } = this.config.preprocess;\n\n    // Grayscale, to help line-identification.\n    cv.cvtColor(this.source, this.source, cv.COLOR_RGBA2GRAY, 0);\n    // Blur, to smooth out noise.\n    const blurKernel = new cv.Size(blurRadius, blurRadius);\n    cv.GaussianBlur(this.source, this.source, blurKernel, 0, 0, cv.BORDER_DEFAULT);\n    // Convert to black & white.\n    cv.adaptiveThreshold(\n      this.source,\n      this.source,\n      255, // black\n      cv.ADAPTIVE_THRESH_MEAN_C,\n      cv.THRESH_BINARY,\n      thresholdBlur,\n      thresholdNorm\n    );\n  }\n\n  /**\n   * Finds the contour (shape, in OpenCV) surrounding the largest Sudoku-like square in the source\n   * image.\n   */\n  protected findLargestSquare(): cv.Mat | null {\n    const contours = new cv.MatVector();\n    const hierarchy = new cv.Mat();\n\n    cv.findContours(this.source, contours, hierarchy, cv.RETR_TREE, cv.CHAIN_APPROX_SIMPLE);\n\n    let largestArea = 0;\n    let largestSquare = null;\n\n    for (let i = 0; i < contours.size(); i++) {\n      const contour = contours.get(i);\n      const simplified = simplifyContour(contour);\n\n      // TODO: Add additional constraints, e.g.parallel Hough lines, to reduce false positives?\n      if (isContourSquarish(simplified, this.source, this.config.minSize, this.config.maxSize)) {\n        const area = cv.contourArea(simplified);\n        if (area > largestArea) {\n          largestArea = area;\n          largestSquare = simplified.clone();\n        }\n      }\n      contour.delete();\n      simplified.delete();\n    }\n\n    contours.delete();\n    hierarchy.delete();\n\n    return largestSquare;\n  }\n\n  /**\n   * Loads the Scanner's dependencies in a browser context (please note, this must be done manually\n   * if using node). This must be resolved before the class is used.\n   *\n   * @param timeLimit The time, in ms, after which an Error will be thrown, if the dependencies have\n   *                  not loaded.\n   */\n  static async loadDependencies(timeLimit?: number): Promise<void> {\n    if (isNode || typeof cv !== 'undefined') return Promise.resolve();\n\n    return loadScript('opencv.js', timeLimit);\n  }\n}\n","import { cover } from 'intrinsic-scale';\nimport { RefObject, useCallback, useEffect, useState } from 'react';\n\nimport { SudokuScanner as SudokuScannerService } from '../services';\nimport { SudokuDigitImages } from '../types/interfaces/SudokuScanner';\n\n// This results in an optimal character height for OCR, see:  https://groups.google.com/g/tesseract-ocr/c/Wdh_JJwnw94/m/24JHDYQbBQAJ\nconst SUDOKU_SIZE = 540;\nconst buffer = document.createElement('canvas');\nbuffer.width = SUDOKU_SIZE;\nbuffer.height = SUDOKU_SIZE;\n\nconst getFrame = (video: HTMLVideoElement, mask: HTMLElement): ImageData | null => {\n  const { width: displayWidth, height: displayHeight } = video.getBoundingClientRect();\n  const { width: scaledWidth, height: scaledHeight, x: cropX, y: cropY } = cover(\n    displayWidth,\n    displayHeight,\n    video.videoWidth,\n    video.videoHeight\n  );\n  const scale = cropX ? video.videoHeight / scaledHeight : video.videoWidth / scaledWidth;\n  const videoMask = {\n    x: scale * (mask.offsetLeft - video.offsetLeft - cropX),\n    y: scale * (mask.offsetTop - video.offsetTop - cropY),\n    width: scale * mask.offsetWidth,\n    height: scale * mask.offsetHeight,\n  };\n\n  const ctx = buffer.getContext('2d');\n  if (!ctx) return null;\n\n  ctx.drawImage(\n    video,\n    videoMask.x,\n    videoMask.y,\n    videoMask.width,\n    videoMask.height,\n    0,\n    0,\n    buffer.width,\n    buffer.height\n  );\n\n  return ctx.getImageData(0, 0, buffer.width, buffer.height);\n};\n\nexport default function useScanner(\n  source: RefObject<HTMLVideoElement>,\n  output: RefObject<HTMLCanvasElement>,\n  scanHz = 30\n): [boolean | null, SudokuDigitImages | null] {\n  const [scannerLoaded, setScannerLoaded] = useState<boolean | null>(null);\n  const [digitImages, setDigitImages] = useState<SudokuDigitImages | null>(null);\n\n  // Continuously scan the source video, until a sudoku-like image is found.\n  const scanSource = useCallback(() => {\n    const start = Date.now();\n    let found = false;\n\n    if (source.current && output.current) {\n      const frame = getFrame(source.current, output.current);\n      if (frame) {\n        const scanner = new SudokuScannerService(frame);\n        found = scanner.extractSudokuImage(output.current);\n        found && setDigitImages(scanner.extractDigits());\n        scanner.destruct();\n      }\n    }\n\n    const timeTaken = Date.now() - start;\n    !found && setTimeout(scanSource, 1000 / scanHz - timeTaken);\n  }, [output, scanHz, source]);\n\n  useEffect(() => {\n    if (scannerLoaded === null) {\n      SudokuScannerService.loadDependencies().then(() => {\n        // Prevent blocking the main thread for too long, so the browser doesn't think we're mining\n        // bitcoin! 😆\n        setTimeout(scanSource, 100);\n        setScannerLoaded(true);\n      });\n      setScannerLoaded(false);\n    }\n  }, [scanSource, scannerLoaded]);\n\n  return [scannerLoaded, digitImages];\n}\n","import styles from './Ellipsis.module.scss';\n\nexport default function Ellipsis() {\n  return (\n    <span>\n      <span className={styles.one}>.</span>\n      <span className={styles.two}>.</span>\n      <span className={styles.three}>.</span>\n    </span>\n  );\n}\n","import styles from './LoadingBlocks.module.scss';\n\nexport default function LoadingBlocks() {\n  return (\n    <div className={styles.loadingBlocks}>\n      <span className={styles.block1} />\n      <span className={styles.block2} />\n      <span className={styles.block3} />\n      <span className={styles.block4} />\n      <span className={styles.block5} />\n      <span className={styles.block6} />\n      <span className={styles.block7} />\n      <span className={styles.block8} />\n      <span className={styles.block9} />\n    </div>\n  );\n}\n","import { RefObject, useEffect, useRef } from 'react';\n\nimport { useReader, useScanner } from '../hooks';\nimport { Sudoku } from '../types/interfaces/SudokuSolver';\nimport { Ellipsis, LoadingBlocks } from './Animations';\nimport styles from './SudokuScanner.module.scss';\n\n/**\n * Visual UI, designed to be rendered on top of the <video> element that is its source. The video\n * source is scanned for Sudoku-like objects.\n */\nexport default function SudokuScanner({ source, onFound, scanHz }: Props) {\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n  const [scannerLoaded, digitImages] = useScanner(source, canvasRef, scanHz);\n  const [readerLoaded, sudoku] = useReader(digitImages);\n\n  let loadingMessage = '';\n  if (!scannerLoaded) loadingMessage = 'Please wait while the scanner loads';\n  else if (digitImages && !readerLoaded) loadingMessage = 'Please wait while the reader loads';\n\n  useEffect(() => {\n    sudoku && onFound(sudoku);\n  }, [onFound, sudoku]);\n\n  // Both the SudokuScanner and TextReader have large (~10+ MB) dependencies to load (which, even\n  // if cached, can still take several seconds to parse). We want to make the experience seem as\n  // fast as possible for the user; so we proceed as far as we can at each step, before hitting a\n  // roadblock (where we are forced to display a \"this library is loading...\" message).\n  return (\n    <div className={styles.sudokuScanner}>\n      <canvas ref={canvasRef} />\n      {loadingMessage && (\n        <div className={styles.loadingMessage}>\n          <LoadingBlocks />\n          <span>\n            {loadingMessage}\n            <Ellipsis />\n          </span>\n        </div>\n      )}\n    </div>\n  );\n}\n\ntype Props = {\n  source: RefObject<HTMLVideoElement>;\n  onFound(sudoku: Sudoku): void;\n  scanHz?: number;\n};\n","import { useCallback, useEffect, useMemo, useState } from 'react';\n\nimport { TextReader } from '../services';\nimport { SudokuDigitImages } from '../types/interfaces/SudokuScanner';\nimport { Sudoku } from '../types/interfaces/SudokuSolver';\n\nexport default function useReader(\n  digitImages: SudokuDigitImages | null\n): [boolean | null, Sudoku | null] {\n  const [readerLoaded, setReaderLoaded] = useState<boolean | null>(null);\n  const [sudoku, setSudoku] = useState<Sudoku | null>(null);\n  const digitReader = useMemo(() => new TextReader({ whitelist: '123456789', single: true }), []);\n\n  /**\n   * Runs OCR on `digitImages`, if is populated. The resulting 2D array of numbers, is used to\n   * build a Sudoku object, which is returned to the parent via `onFound()`.\n   */\n  const readPendingDigits = useCallback(\n    () =>\n      digitImages &&\n      Promise.all(\n        digitImages.map(row =>\n          Promise.all(\n            row.map(async digit => (digit ? parseInt(await digitReader.read(digit), 10) || 0 : 0))\n          )\n        )\n      ).then(setSudoku),\n    [digitImages, digitReader]\n  );\n\n  useEffect(() => {\n    if (readerLoaded === null) {\n      digitReader.load().then(() => {\n        readPendingDigits();\n        setReaderLoaded(true);\n      });\n      setReaderLoaded(false);\n    }\n    readerLoaded && readPendingDigits();\n  }, [digitImages, digitReader, readPendingDigits, readerLoaded]);\n\n  useEffect(\n    () => () => {\n      // It's safer to call the destructor here, in case the component is unmounted before a sudoku\n      // is found.\n      digitReader.destruct(); // TODO: Move scanner and reader into global or parent state.\n    },\n    [digitReader]\n  );\n\n  return [readerLoaded, sudoku];\n}\n","import structuredClone from '@ungap/structured-clone';\n\nimport { SudokuSolver as SudokuSolverService } from '../services';\nimport { Sudoku } from '../types/interfaces/SudokuSolver';\nimport styles from './SudokuSolver.module.scss';\n\nexport default function SudokuSolver({ sudoku }: { sudoku: Sudoku }) {\n  // If we don't clone it, the original sudoku is modified and a wierd occurs, where all the table\n  // cells are rendered as original!\n  const sudokuSolver = new SudokuSolverService(structuredClone(sudoku));\n  const solved = sudokuSolver.isValid() ? sudokuSolver.solve() : null;\n\n  let key = 0;\n  return (\n    <table className={styles.sudokuSolver}>\n      <tbody>\n        {solved ? (\n          solved.map((row, r) => (\n            <tr key={key}>\n              {row.map((cell, c) => (\n                // eslint-disable-next-line no-plusplus -- 🙄\n                <td key={key++} className={sudoku[r][c] ? styles.original : ''}>\n                  {cell}\n                </td>\n              ))}\n            </tr>\n          ))\n        ) : (\n          <div className={styles.error}>\n            <div>\n              <h2>Scan Failed</h2>\n              <p>Please try to ensure the image is clear and not obstructed by anything.</p>\n              <p>(PS: webcams or partially-completed sudokus likely won&apos;t work!)</p>\n            </div>\n          </div>\n        )}\n      </tbody>\n    </table>\n  );\n}\n","import styles from './Overlay.module.scss';\n\nexport default function Overlay({ corners }: { corners: boolean }) {\n  return (\n    <div className={styles.overlay} role=\"application\">\n      {corners && (\n        <>\n          <div className={`${styles.corner} ${styles.top} ${styles.left}`} />\n          <div className={`${styles.corner} ${styles.top} ${styles.right}`} />\n          <div className={`${styles.corner} ${styles.bottom} ${styles.left}`} />\n          <div className={`${styles.corner} ${styles.bottom} ${styles.right}`} />\n        </>\n      )}\n    </div>\n  );\n}\n","import { useRef, useState } from 'react';\n\nimport styles from './App.module.scss';\nimport { Camera, CameraStatus, Overlay, SudokuScanner, SudokuSolver } from './components';\nimport { Sudoku } from './types/interfaces/SudokuSolver';\n\nexport default function App() {\n  const [cameraStatus, setCameraStatus] = useState(CameraStatus.Loading);\n  const [sudoku, setSudoku] = useState<Sudoku | null>(null);\n  const videoRef = useRef<HTMLVideoElement>(null);\n\n  return (\n    <div className={styles.app}>\n      <header>\n        <h1>🧮 Sudoku Solver</h1>\n      </header>\n      <Camera ref={videoRef} onStatusUpdate={setCameraStatus} />\n      <main>\n        {cameraStatus === CameraStatus.Active && !sudoku && (\n          <SudokuScanner source={videoRef} scanHz={10} onFound={setSudoku} />\n        )}\n        {sudoku && <SudokuSolver sudoku={sudoku} />}\n        <Overlay corners={!sudoku} />\n      </main>\n      <footer>\n        <nav>\n          {sudoku && (\n            <button type=\"button\" onClick={() => setSudoku(null)}>\n              Reset\n            </button>\n          )}\n        </nav>\n        <p>\n          📟{' '}\n          <a href=\"https://github.com/SamChristy/sudoku-solver\" target=\"_blank\" rel=\"noreferrer\">\n            see code\n          </a>\n        </p>\n      </footer>\n    </div>\n  );\n}\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://cra.link/PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(/^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/)\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL || '', window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://cra.link/PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://cra.link/PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log('No internet connection found. App is running in offline mode.');\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import './index.scss';\n\nimport React from 'react';\nimport ReactDOM from 'react-dom';\n\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\nimport * as serviceWorkerRegistration from './serviceWorkerRegistration';\nimport { fixViewportHeightInMobileSafari, loadMobileConsole } from './util/browser';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\nwindow.location.search.includes('console') && loadMobileConsole();\nfixViewportHeightInMobileSafari();\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://cra.link/PWA\nserviceWorkerRegistration.unregister();\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}