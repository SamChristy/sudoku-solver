{"version":3,"sources":["services/TextReader/TextReader.ts","App.module.scss","components/SudokuSolver.module.scss","components/Camera.tsx","util/camera.ts","util/browser.ts","util/geometry.ts","services/lib/cv.ts","services/SudokuScanner/SudokuScanner.ts","components/SudokuScanner.tsx","components/SudokuSolver.tsx","App.tsx","reportWebVitals.ts","serviceWorkerRegistration.ts","index.tsx"],"names":["TextReader","config","scheduler","language","threadCount","whiteList","single","getTesseractConfig","tesseractConfig","tessedit_ocr_engine_mode","user_defined_dpi","tessedit_pageseg_mode","tessedit_char_whitelist","workerConfig","isNode","langPath","path","join","__dirname","cacheMethod","gzip","process","workerPath","corePath","this","createScheduler","addThread","a","worker","createWorker","load","loadLanguage","initialize","setParameters","addWorker","Promise","allSettled","Array","fill","map","imageSource","addJob","data","text","slice","terminate","module","exports","CameraStatus","idealCameraConstraints","width","ideal","height","facingMode","focusMode","whiteBalance","exposureMode","identifyPrimaryCamera","navigator","mediaDevices","enumerateDevices","inputDevices","cameras","filter","device","kind","length","Error","backFacingCameras","camera","label","includes","turnOnCamera","videoElement","dimensions","constraints","video","deviceId","undefined","audio","getUserMedia","srcObject","play","Camera","forwardRef","ref","onStatusUpdate","useEffect","current","catch","name","Denied","Unavailable","getVideoTracks","stop","onLoadedMetadata","Active","onSuspend","playsInline","muted","loadScript","url","timeout","script","document","createElement","startsWith","src","body","appendChild","resolve","reject","timeoutId","window","setTimeout","addEventListener","clearTimeout","loadMobileConsole","eruda","init","distance","x1","y1","x2","y2","closest","reference","points","distances","point","closestDistance","reduce","closestPoint","i","measureSides","coords","coord","isPointInsideRect","rect","x","y","getContourPathCoords","contour","pointVector","from","data32S","simplifyContour","simplified","cv","Mat","epsilon","arcLength","approxPolyDP","isContourSquarish","container","minSize","maxSize","size","minArea","Math","min","rows","cols","sizeLimit","max","contourArea","sortedLengths","sort","longest","pop","every","cropAndFlatten","rectangleContour","sourceWidth","sourceHeight","contourCoords","topLeft","topRight","bottomLeft","bottomRight","newWidth","newHeight","flattened","zeros","CV_8UC3","Size","srcTri","matFromArray","CV_32FC2","dstTri","transformMatrix","getPerspectiveTransform","warpPerspective","INTER_LINEAR","BORDER_CONSTANT","delete","split","columns","squares","squareWidth","squareHeight","r","c","crop","Rect","roi","cropCellBorders","binary","cellCenter","round","cellArea","maxArea","contours","MatVector","hierarchy","findContours","RETR_TREE","CHAIN_APPROX_SIMPLE","largestArea","largestRect","get","boundingRect","area","shapeRatio","binaryCellContents","isCellEmpty","mean","CV_64F","stdDev","meanStdDev","doubleAt","isEmpty","padding","SudokuScanner","source","preprocess","blurRadius","thresholdBlur","thresholdNorm","original","processed","constructor","matFromImageData","imread","clone","outputCanvas","preprocessImage","largestSquare","findLargestSquare","colour","imshow","extractSudokuImage","extractDigits","originalCells","binaryCells","grid","row","colourCell","binaryCell","digitMat","canvas","push","cvtColor","COLOR_RGBA2GRAY","blurKernel","GaussianBlur","BORDER_DEFAULT","adaptiveThreshold","ADAPTIVE_THRESH_MEAN_C","THRESH_BINARY","timeLimit","onFound","scanHz","useState","loadingStarted","setLoadingStarted","scannerLoaded","setScannerLoaded","readerLoaded","setReaderLoaded","digitImages","setDigitImages","canvasRef","useRef","digitReader","useMemo","scanSource","useCallback","start","Date","now","found","frame","buffer","videoWidth","videoHeight","ctx","getContext","drawImage","getImageData","getFrame","scanner","SudokuScannerService","destruct","timeTaken","readPendingDigits","all","digit","read","then","loadDependencies","SudokuSolver","sudoku","className","styles","sudokuSolver","cell","App","Loading","cameraStatus","setCameraStatus","setSudoku","videoRef","app","type","onClick","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","Boolean","location","hostname","match","ReactDOM","render","StrictMode","getElementById","search","serviceWorker","ready","registration","unregister","error","console","message"],"mappings":"8PAcqBA,E,WAUnB,WAAYC,GAAqC,yBAT9BC,eAS6B,OAR7BC,SAAW,MAQkB,KAP7BF,OAA2B,CAE5CG,YAAa,EACbC,UAAW,GACXC,QAAQ,GAGsC,KAsCtCC,mBAAqB,WAuB7B,MAAO,CAAEC,gBAtBsC,CAC7CC,yBAA0B,EAC1BC,iBAAkB,MAClBC,sBAAuB,KACvBC,wBAAyB,aAkBDC,aAdmBC,IACzC,CACEC,SAAUC,IAAKC,KAAKC,EAAW,KAAM,KAAM,KAAM,SAAU,OAG3DC,YAAa,OACbC,MAAM,GAER,CACEL,SAAS,GAAD,OAAKM,iBAAL,QACRC,WAAW,GAAD,OAAKD,iBAAL,sBACVE,SAAS,GAAD,OAAKF,iBAAL,kCAzDdG,KAAKvB,OAAL,2BAAmBuB,KAAKvB,QAAWA,GACnCuB,KAAKtB,UAAYuB,4B,+EAInB,0GAC4CD,KAAKjB,qBAAvCM,EADV,EACUA,aAAcL,EADxB,EACwBA,gBAChBkB,EAFR,uCAEoB,4BAAAC,EAAA,6DACVC,EAASC,uBAAahB,GADZ,SAGVe,EAAOE,OAHG,uBAIVF,EAAOG,aAAa,EAAK5B,UAJf,uBAKVyB,EAAOI,WAAW,EAAK7B,UALb,uBAMVyB,EAAOK,cAAczB,GANX,OAQhB,EAAKN,UAAUgC,UAAUN,GART,4CAFpB,8DAaQO,QAAQC,WAAWC,MAAMb,KAAKvB,OAAOG,aAAakC,KAAK,GAAGC,IAAIb,IAbtE,gD,+GAiBA,WAAkBc,GAAlB,yFACyBhB,KAAKtB,UAAUuC,OAAO,YAAaD,GAD5D,uBACUE,EADV,EACUA,KADV,kBAISlB,KAAKvB,OAAOK,OAASoC,EAAKC,KAAKC,MAAM,EAAG,GAAKF,EAAKC,MAJ3D,gD,oHAQA,8FACQnB,KAAKtB,UAAU2C,YADvB,gD,kGCtDFC,EAAOC,QAAU,CAAC,IAAM,mB,mBCAxBD,EAAOC,QAAU,CAAC,aAAe,qC,sECIrBC,E,uFCGNC,EAAyB,CAC7BC,MAAO,CAAEC,MAAO,MAChBC,OAAQ,CAAED,MAAO,MACjBE,WAAY,CAAEF,MAAO,eACrBG,UAAW,CAAEH,MAAO,cACpBI,aAAc,CAAEJ,MAAO,cACvBK,aAAc,CAAEL,MAAO,eAMZM,EAAqB,uCAAG,gCAAA9B,EAAA,sEACR+B,UAAUC,aAAaC,mBADf,UAC7BC,EAD6B,QAE7BC,EAAUD,EAAaE,QAAO,SAAAC,GAAM,MAAoB,eAAhBA,EAAOC,SAExCC,OAJsB,sBAIR,IAAIC,MAAM,oBAJF,cAM7BC,EAAoBN,EAAQC,QAAO,SAAAM,GAAM,OAAIA,EAAOC,MAAMC,SAAS,kBANtC,kBAS5BH,EAAkBF,OAASE,EAAkBA,EAAkBF,OAAS,GAAK,MATjD,2CAAH,qDAerBM,EAAY,uCAAG,WAAOC,EAAgCC,GAAvC,iBAAA/C,EAAA,sEACL8B,IADK,cACpBY,EADoB,OAEpBM,EAAc,CAClBC,MAAM,2BACD3B,GADA,IAGH4B,UAAgB,OAANR,QAAM,IAANA,OAAA,EAAAA,EAAQQ,UAAWR,EAAOQ,cAAWC,GAC3CJ,GAAc,CAChBxB,MAAO,CAAEC,MAAOuB,EAAWxB,OAC3BE,OAAQ,CAAED,MAAOuB,EAAWtB,UAGhC2B,OAAO,GAZiB,SAeKrB,UAAUC,aAAaqB,aAAaL,GAfzC,cAe1BF,EAAaQ,UAfa,gBAgBpBR,EAAaS,OAhBO,2CAAH,wD,iBD9BblC,O,qBAAAA,I,mBAAAA,I,mBAAAA,I,8BAAAA,M,KAUZ,IAyCemC,EAzCAC,sBAAoC,WAA4BC,GAAS,IAAlCC,EAAiC,EAAjCA,eA6BpD,OA5BAC,qBAAU,WAAO,IACPC,EAAYH,EAAZG,QACR,OAAKA,GAKLhB,EAAagB,EAAS,CAAEtC,MAAO,IAAKE,OAAQ,MAAOqC,OAAM,gBAAGC,EAAH,EAAGA,KAAH,OACvDJ,EAAwB,oBAATI,EAA6B1C,EAAa2C,OAAS3C,EAAa4C,gBAc1E,WACSJ,EC8BUP,UACrBY,iBAAiB,GAAGC,SDpDJ,eAwBpB,CAACR,EAAgBD,IAGlB,uBACEA,IAAKA,EACLU,iBAAkB,kBAAMT,EAAetC,EAAagD,SACpDC,UAAW,kBAAMX,EAAetC,EAAa4C,cAC7CM,aAAW,EACXC,OAAK,O,+BE3CEC,EAAU,uCAAG,WAAOC,GAAP,6BAAA1E,EAAA,6DAAoB2E,EAApB,+BAA8B,IAChDC,EAASC,SAASC,cAAc,UAElCJ,EAAIK,WAAW,QAASH,EAAOI,IAAMN,EAChCA,EAAIK,WAAW,KAAMH,EAAOI,IAAP,UAAgBtF,kBAAhB,OAAyCgF,GAClEE,EAAOI,IAAP,UAAgBtF,iBAAhB,YAA0CgF,GAE/CG,SAASI,KAAKC,YAAYN,GAPF,kBASjB,IAAIpE,SAAQ,SAAC2E,EAASC,GAC3B,IAAMC,EAAYC,OAAOC,YACvB,kBAAMH,EAAO,IAAI5C,MAAJ,UAAakC,EAAb,+BACbC,GAGFC,EAAOY,iBAAiB,QAAQ,WAC9BF,OAAOG,aAAaJ,GACpBF,WAjBoB,2CAAH,sDA2BVO,EAAiB,uCAAG,sBAAA1F,EAAA,sEACzByE,EAAW,qBADc,OAG/BkB,MAAMC,OAHyB,2CAAH,qD,QCzBjBC,EAAW,SAAC,EAAD,0BAAEC,EAAF,KAAMC,EAAN,wBAAmBC,EAAnB,KAAuBC,EAAvB,qBACrB,SAACH,EAAKE,EAAO,GAAb,SAAkBD,EAAKE,EAAO,GAAO,KAE3BC,EAAU,SAACC,EAAkBC,GACxC,IAAMC,EAAYD,EAAOxF,KAAI,SAAA0F,GAAK,OAAIT,EAASM,EAAWG,MACtDC,EAAkBF,EAAU,GAEhC,OAAOD,EAAOI,QAAO,SAACC,EAAcH,EAAOI,GACzC,OAAIL,EAAUK,GAAKH,GACjBA,EAAkBF,EAAUK,GACrBJ,GAEFG,MAIEE,EAAe,SAACC,GAAD,OAC1BA,EAAOhG,KAAI,SAACiG,EAAOH,GAAR,OAAcb,EAASgB,EAAOD,EAAOF,EAAIE,EAAOrE,OAAS,EAAImE,EAAI,EAAI,QAErEI,EAAoB,SAACR,EAAcS,GAAf,OAC/BT,EAAM,IAAMS,EAAKC,GACjBV,EAAM,IAAMS,EAAKE,GACjBX,EAAM,IAAMS,EAAKC,EAAID,EAAKxF,OAC1B+E,EAAM,IAAMS,EAAKE,EAAIF,EAAKtF,QChBfyF,EAAuB,SAACC,GAGnC,IAFA,IAAMC,EAAc1G,MAAM2G,KAAKF,EAAQG,SACjCV,EAASlG,MAAM,GACZgG,EAAI,EAAGA,EAAI,EAAGA,IAAKE,EAAOF,GAAKU,EAAYnG,MAAU,EAAJyF,EAAW,EAAJA,EAAQ,GAEzE,OAAOE,GAMIW,EAAkB,SAACJ,GAC9B,IAAMK,EAAa,IAAIC,GAAGC,IACpBC,EA1BwB,IA0BYF,GAAGG,UAAUT,GAAS,GAGhE,OADAM,GAAGI,aAAaV,EAASK,EAAYG,GAAS,GACvCH,GAYIM,EAAoB,SAC/BX,EACAY,GAGa,IAFbC,EAEY,uDAFF,EACVC,EACY,uDADF,EAGV,GAA8B,IAA1Bd,EAAQe,OAAOzG,OAAc,OAAO,EAExC,IAAKsG,EAAW,OAAO,EAGvB,IAAMI,EAAUC,KAAK,IAALA,KAAKC,IAAIN,EAAUO,KAAMP,EAAUQ,MAAS,GAAIP,EAC1DQ,EAAYJ,KAAKK,IAAIV,EAAUO,KAAMP,EAAUQ,MAAQN,EAE7D,GAAIR,GAAGiB,YAAYvB,IAAYgB,EAAS,CACtC,IAAMvB,EAASM,EAAqBC,GAG9BwB,EAAgBhC,EAAaC,GAAQgC,OACrCC,EAAUF,EAAcG,MAC9B,QAAKD,IAGHA,EAAUL,GACVG,EAAcI,OAAM,SAAAxG,GAAM,OAAIA,EAjEL,GAiEuCsG,MAIpE,OAAO,GAGIG,EAAiB,SAAChE,EAAaiE,GAAsC,IAAD,EAC3C,CAACjE,EAAIuD,KAAMvD,EAAIsD,MAA5CY,EADwE,KAC3DC,EAD2D,KAIzEC,EAAgBlC,EAAqB+B,GACrCI,EAAUnD,EAAQ,CAAC,EAAG,GAAIkD,GAC1BE,EAAWpD,EAAQ,CAACgD,EAAa,GAAIE,GACrCG,EAAarD,EAAQ,CAAC,EAAGiD,GAAeC,GACxCI,EAActD,EAAQ,CAACgD,EAAaC,GAAeC,GAGnDK,EAAWrB,KAAKC,IAAIiB,EAAS,GAAKD,EAAQ,GAAIG,EAAY,GAAKD,EAAW,IAC1EG,EAAYtB,KAAKC,IAAIkB,EAAW,GAAKF,EAAQ,GAAIG,EAAY,GAAKF,EAAS,IAC3EK,EAAYlC,GAAGC,IAAIkC,MAAMH,EAAUC,EAAWjC,GAAGoC,SACjD3B,EAAO,IAAIT,GAAGqC,KAAKL,EAAUC,GAI7BK,EAAStC,GAAGuC,aAAa,EAAG,EAAGvC,GAAGwC,SAAzB,sBACVZ,GADU,YAEVC,GAFU,YAGVE,GAHU,YAIVD,KAECW,EAASzC,GAAGuC,aAAa,EAAG,EAAGvC,GAAGwC,SAAU,CAChD,EACA,EACAR,EACA,EACAA,EACAC,EACA,EACAA,IAEIS,EAAkB1C,GAAG2C,wBAAwBL,EAAQG,GAO3D,OANAzC,GAAG4C,gBAAgBrF,EAAK2E,EAAWQ,EAAiBjC,EAAMT,GAAG6C,aAAc7C,GAAG8C,iBAE9EJ,EAAgBK,SAChBT,EAAOS,SACPN,EAAOM,SAEAb,GAGIc,EAAQ,SAACzF,EAAasD,EAAcoC,GAK/C,IAJA,IAAMC,EAAsB,IAAIjK,MAAM4H,GAChCsC,EAAc5F,EAAIuD,KAAOmC,EACzBG,EAAe7F,EAAIsD,KAAOA,EAEvBwC,EAAI,EAAGA,EAAIxC,EAAMwC,IAAK,CAC7BH,EAAQG,GAAK,IAAIpK,MAAMgK,GACvB,IAAK,IAAIK,EAAI,EAAGA,EAAIL,EAASK,IAAK,CAChC,IAAM/D,EAAI+D,EAAIH,EACR3D,EAAI6D,EAAID,EACRG,EAAO,IAAIvD,GAAGwD,KAAKjE,EAAGC,EAAG2D,EAAaC,GAC5CF,EAAQG,GAAGC,GAAK/F,EAAIkG,IAAIF,IAI5B,OAAOL,GAeIQ,EAAkB,SAACnG,EAAaoG,GAC3C,IAAMC,EAAa,CAACjD,KAAKkD,MAAMF,EAAO9C,KAAO,GAAIF,KAAKkD,MAAMF,EAAO7C,KAAO,IACpEgD,EAAWH,EAAO9C,KAAO8C,EAAO7C,KAChCJ,EApJc,IAoJYoD,EAC1BC,EApJc,GAoJYD,EAC1BE,EAAW,IAAIhE,GAAGiE,UAClBC,EAAY,IAAIlE,GAAGC,IAEzBD,GAAGmE,aAAaR,EAAQK,EAAUE,EAAWlE,GAAGoE,UAAWpE,GAAGqE,qBAC9DH,EAAUnB,SAKV,IAHA,IAAIuB,EAAc,EACdC,EAAc,KAETtF,EAAI,EAAGA,EAAI+E,EAASvD,OAAQxB,IAAK,CACxC,IAAMS,EAAUsE,EAASQ,IAAIvF,GACvBK,EAAOU,GAAGyE,aAAa/E,GACvBgF,EAAOpF,EAAKxF,MAAQwF,EAAKtF,OACzB2K,EAAarF,EAAKxF,MAAQwF,EAAKtF,OAGnC0K,EAAOhE,GACPgE,EAAOX,GACPY,EAtKwB,IAuKxBA,EAtKwB,KAuKxBtF,EAAkBuE,EAAYtE,IAC9BoF,EAAOJ,IAEPA,EAAcI,EACdH,EAAcjF,GAEhBI,EAAQqD,SAGV,GAAoB,OAAhBwB,EAAsB,CAGxB,IAAMK,EAAqBjB,EAAOF,IAAIc,GAChCM,EAlDa,SAACtH,GACtB,IAAMuH,EAAO,IAAI9E,GAAGC,IAAI,EAAG,EAAGD,GAAG+E,QAC3BC,EAAS,IAAIhF,GAAGC,IAAI,EAAG,EAAGD,GAAG+E,QAGnC,OAFA/E,GAAGiF,WAAW1H,EAAKuH,EAAME,GAElBF,EAAKI,SAAS,EAAG,IArIG,IAkLLC,CAAQP,GAG5B,GAFAA,EAAmB7B,UAEd8B,EAAa,CAEhB,IAAMO,EAAUzE,KAAKkD,MAtLN,IAsLwB,SAAGC,EAAa,KAYvD,OARAS,EAAYhF,EAAIoB,KAAKK,IAAIuD,EAAYhF,EAAI6F,EAAS,GAClDb,EAAY/E,EAAImB,KAAKK,IAAIuD,EAAY/E,EAAI4F,EAAS,GAGlDb,EAAYzK,MAAQ6G,KAAKC,IAAI2D,EAAYzK,MAAQ,EAAIsL,EAAS7H,EAAIuD,KAAOyD,EAAYhF,GACrFgF,EAAYvK,OAAS2G,KAAKC,IAAI2D,EAAYvK,OAAS,EAAIoL,EAAS7H,EAAIsD,KAAO0D,EAAY/E,GAEvFwE,EAASjB,SACFxF,EAAIkG,IAAIc,IAInB,OADAP,EAASjB,SACF,MC/LYsC,E,WA6BnB,WAAYC,EAAuCzO,GACjD,GADyF,yBA3BxEA,OAA8B,CAC/CgK,KAAM,EACNoC,QAAS,EACTsC,WAAY,CACVC,WAAY,GACZC,cAAe,EACfC,cAAe,GAEjBnF,QAAS,IACTC,QAAS,KAkB+E,KAdhFmF,cAcgF,OAZhFL,YAYgF,OAVhFM,eAUgF,GACnF5F,GAAI,MAAM,IAAIjF,MAAM,0BAEzB3C,KAAKuN,SACyB,cAA5BL,EAAOO,YAAYvJ,KAAuB0D,GAAG8F,iBAAiBR,GAAUtF,GAAG+F,OAAOT,GACpFlN,KAAKkN,OAASlN,KAAKuN,SAASK,QAC5B5N,KAAKvB,OAAL,2BAAmBuB,KAAKvB,QAAWA,G,sDAIrC,SAA0BoP,GAExB7N,KAAK8N,kBACL,IAAMC,EAAgB/N,KAAKgO,oBAE3B,OAAsB,OAAlBD,GACF/N,KAAKwN,UAAY,CACfS,OAAQ9E,EAAenJ,KAAKuN,SAAUQ,GACtCxC,OAAQpC,EAAenJ,KAAKkN,OAAQa,IAGtCA,EAAcpD,SACd3K,KAAKuN,SAAS5C,SACd3K,KAAKkN,OAAOvC,SAEZkD,GAAgBjG,GAAGsG,OAAOL,EAAc7N,KAAKwN,UAAUS,SAChD,IAGTjO,KAAKwN,UAAY,MACV,K,2BAIT,WAEE,GAAuB,OAAnBxN,KAAKwN,UAAoB,OAAO,KAGpC,QAAuBlK,IAAnBtD,KAAKwN,UAEP,OADAxN,KAAKmO,qBACEnO,KAAKoO,gBAOd,IAJA,IAAMC,EAAgBzD,EAAM5K,KAAKwN,UAAUS,OAAQjO,KAAKvB,OAAOgK,KAAMzI,KAAKvB,OAAOoM,SAC3EyD,EAAc1D,EAAM5K,KAAKwN,UAAUjC,OAAQvL,KAAKvB,OAAOgK,KAAMzI,KAAKvB,OAAOoM,SACzE0D,EAAuC,GAEpCtD,EAAI,EAAGA,EAAIjL,KAAKvB,OAAOgK,KAAMwC,IAAK,CAGzC,IAFA,IAAMuD,EAAM,GAEHtD,EAAI,EAAGA,EAAIlL,KAAKvB,OAAOoM,QAASK,IAAK,CAC5C,IAAMuD,EAAaJ,EAAcpD,GAAGC,GAC9BwD,EAAaJ,EAAYrD,GAAGC,GAC5ByD,EAAWrD,EAAgBmD,EAAYC,GAE7C,GAAIC,EAAU,CACZ,IAAMC,EAAS5J,SAASC,cAAc,UACtCuJ,EAAIK,KAAKD,GACThH,GAAGsG,OAAOU,EAAQD,GAElBA,EAAShE,cACJ6D,EAAIK,KAAK,MAEhBJ,EAAW9D,SACX+D,EAAW/D,SAGb4D,EAAKM,KAAKL,GAGZ,OAAOD,I,sBAIT,WAGMvO,KAAKwN,WACPxN,KAAKwN,UAAUS,OAAOtD,SACtB3K,KAAKwN,UAAUjC,OAAOZ,WAEtB3K,KAAKuN,SAAS5C,SACd3K,KAAKkN,OAAOvC,Y,6BAQhB,WAAmC,IAAD,EACqB3K,KAAKvB,OAAO0O,WAAzDC,EADwB,EACxBA,WAAYC,EADY,EACZA,cAAeC,EADH,EACGA,cAGnC1F,GAAGkH,SAAS9O,KAAKkN,OAAQlN,KAAKkN,OAAQtF,GAAGmH,gBAAiB,GAE1D,IAAMC,EAAa,IAAIpH,GAAGqC,KAAKmD,EAAYA,GAC3CxF,GAAGqH,aAAajP,KAAKkN,OAAQlN,KAAKkN,OAAQ8B,EAAY,EAAG,EAAGpH,GAAGsH,gBAE/DtH,GAAGuH,kBACDnP,KAAKkN,OACLlN,KAAKkN,OACL,IACAtF,GAAGwH,uBACHxH,GAAGyH,cACHhC,EACAC,K,+BAQJ,WACE,IAAM1B,EAAW,IAAIhE,GAAGiE,UAClBC,EAAY,IAAIlE,GAAGC,IAEzBD,GAAGmE,aAAa/L,KAAKkN,OAAQtB,EAAUE,EAAWlE,GAAGoE,UAAWpE,GAAGqE,qBAKnE,IAHA,IAAIC,EAAc,EACd6B,EAAgB,KAEXlH,EAAI,EAAGA,EAAI+E,EAASvD,OAAQxB,IAAK,CACxC,IAAMS,EAAUsE,EAASQ,IAAIvF,GACvBc,EAAaD,EAAgBJ,GAGnC,GAAIW,EAAkBN,EAAY3H,KAAKkN,OAAQlN,KAAKvB,OAAO0J,QAASnI,KAAKvB,OAAO2J,SAAU,CACxF,IAAMkE,EAAO1E,GAAGiB,YAAYlB,GACxB2E,EAAOJ,IACTA,EAAcI,EACdyB,EAAgBpG,EAAWiG,SAG/BtG,EAAQqD,SACRhD,EAAWgD,SAMb,OAHAiB,EAASjB,SACTmB,EAAUnB,SAEHoD,K,sEAUT,WAA8BuB,GAA9B,qEACMhQ,KAAwB,qBAAPsI,GADvB,yCACkDjH,QAAQ2E,WAD1D,gCAGSV,EAAW,YAAa0K,IAHjC,2C,sEC7La,SAASrC,EAAT,GAAiE,IAAxCC,EAAuC,EAAvCA,OAAQqC,EAA+B,EAA/BA,QAA+B,IAAtBC,cAAsB,MAAb,GAAa,IACjCC,oBAAS,GADwB,mBACtEC,EADsE,KACtDC,EADsD,OAEnCF,oBAAS,GAF0B,mBAEtEG,EAFsE,KAEvDC,EAFuD,OAGrCJ,oBAAS,GAH4B,mBAGtEK,EAHsE,KAGxDC,EAHwD,OAIvCN,mBAAmC,MAJI,mBAItEO,EAJsE,KAIzDC,EAJyD,KAKvEC,EAAYC,iBAA0B,MACtCC,EAAcC,mBAAQ,kBAAM,IAAI7R,IAAW,CAAEK,UAAW,YAAaC,QAAQ,MAAS,IAKtFwR,EAAaC,uBAAY,WAC7B,IAAMC,EAAQC,KAAKC,MACfC,GAAQ,EAEZ,GAAIzD,GAAUgD,EAAUlM,QAAS,CAC/B,IAAM4M,EL2BY,SAACxN,GACvB,IAAMyN,EAAS7L,SAASC,cAAc,UACtC4L,EAAOnP,MAAQ0B,EAAM0N,WACrBD,EAAOjP,OAASwB,EAAM2N,YACtB,IAAMC,EAAMH,EAAOI,WAAW,MAC9B,OAAKD,GAELA,EAAIE,UAAU9N,EAAO,EAAG,GACjB4N,EAAIG,aAAa,EAAG,EAAGN,EAAOnP,MAAOmP,EAAOjP,SAHlC,KKhCCwP,CAASlE,GACvB,GAAI0D,EAAO,CACT,IAAMS,EAAU,IAAIC,EAAqBV,IACzCD,EAAQU,EAAQlD,mBAAmB+B,EAAUlM,WACpCiM,EAAeoB,EAAQjD,iBAChCiD,EAAQE,YAIZ,IAAMC,EAAYf,KAAKC,MAAQF,GAC9BG,GAASlL,OAAOC,WAAW4K,EAAY,IAAOd,EAASgC,KACvD,CAAChC,EAAQtC,IAMNuE,EAAoBlB,uBACxB,kBACEP,GACArP,QAAQ+Q,IACN1B,EAAYjP,KAAI,SAAAyN,GAAG,OACjB7N,QAAQ+Q,IAAIlD,EAAIzN,KAAI,SAAA4Q,GAAK,OAAKA,EAAQvB,EAAYwB,KAAKD,GAAS,WAElEE,KAAKtC,KACT,CAACS,EAAaT,EAASa,IAmCzB,OAhCArM,qBAAU,WAKH2L,IACH4B,EAAqBQ,mBAAmBD,MAAK,WAC3CvB,IACAT,GAAiB,MAEnBO,EAAY9P,OAAOuR,MAAK,WACtBJ,IACA1B,GAAgB,MAElBJ,GAAkB,MAEnB,CAACD,EAAgB+B,EAAmBrB,EAAaE,IAEpDvM,qBAAU,WACJ+L,GAAc2B,MACjB,CAACA,EAAmB3B,IAEvB/L,qBACE,kBAAM,WAIJqM,EAAYmB,cAEd,CAACnB,IAID,iCACIR,GAAiB,yCAClBI,IAAgBF,GAAgB,wCACjC,wBAAQjM,IAAKqM,O,qBCxFJ,SAAS6B,EAAT,GAAuD,IAA/BC,EAA8B,EAA9BA,OACjCnL,EAAI,EACR,OACE,uBAAOoL,UAAWC,IAAOC,aAAzB,SACE,gCACGH,EAAOjR,KAAI,SAAAyN,GAAG,OACb,6BACGA,EAAIzN,KAAI,SAAAqR,GAAI,OAEX,aADA,CACA,eAAeA,GAANvL,SAHJA,UCHJ,SAASwL,IAAO,IAAD,EACY5C,mBAASjO,EAAa8Q,SADlC,mBACrBC,EADqB,KACPC,EADO,OAEA/C,mBAAwB,MAFxB,mBAErBuC,EAFqB,KAEbS,EAFa,KAGtBC,EAAWvC,iBAAyB,MAE1C,OACE,sBAAK8B,UAAWC,IAAOS,IAAvB,UACE,iCACE,8DAEF,iCACE,cAAC,EAAD,CAAQ9O,IAAK6O,EAAU5O,eAAgB0O,IACtCD,IAAiB/Q,EAAagD,SAAWwN,GACxC,cAAC,EAAD,CAAe9E,OAAQwF,EAAS1O,QAASwL,OAAQ,GAAID,QAASkD,IAE/DT,GAAU,cAAC,EAAD,CAAcA,OAAQA,OAEnC,iCACE,8BACGA,GACC,wBAAQY,KAAK,SAASC,QAAS,kBAAMJ,EAAU,OAA/C,0BCxBZ,IAYeK,EAZS,SAACC,GACnBA,GAAeA,aAAuBC,UACxC,6BAAqBnB,MAAK,YAAkD,IAA/CoB,EAA8C,EAA9CA,OAAQC,EAAsC,EAAtCA,OAAQC,EAA8B,EAA9BA,OAAQC,EAAsB,EAAtBA,OAAQC,EAAc,EAAdA,QAC3DJ,EAAOF,GACPG,EAAOH,GACPI,EAAOJ,GACPK,EAAOL,GACPM,EAAQN,OCGMO,QACW,cAA7B7N,OAAO8N,SAASC,UAEe,UAA7B/N,OAAO8N,SAASC,UAEhB/N,OAAO8N,SAASC,SAASC,MAAM,2DCPnCC,IAASC,OACP,cAAC,IAAMC,WAAP,UACE,cAACvB,EAAD,MAEFrN,SAAS6O,eAAe,SAG1BpO,OAAO8N,SAASO,OAAO/Q,SAAS,YAAc8C,IDmHxC,kBAAmB3D,WACrBA,UAAU6R,cAAcC,MACrBnC,MAAK,SAAAoC,GACJA,EAAaC,gBAEdjQ,OAAM,SAAAkQ,GACLC,QAAQD,MAAMA,EAAME,YC/G5BvB,M","file":"static/js/main.3acfc4fb.chunk.js","sourcesContent":["import isNode from 'detect-node';\nimport path from 'path';\nimport {\n  createScheduler,\n  createWorker,\n  ImageLike,\n  PSM,\n  Scheduler,\n  WorkerOptions,\n  WorkerParams,\n} from 'tesseract.js';\n\nimport TextReaderInterface, { TextReaderConfig } from '../../types/interfaces/TextReader';\n\nexport default class TextReader implements TextReaderInterface {\n  protected readonly scheduler: Scheduler;\n  protected readonly language = 'eng';\n  protected readonly config: TextReaderConfig = {\n    /** 2 threads seems a good compromise on mobile devices */\n    threadCount: 2, // TODO: Dynamically determine optimal thread count.\n    whiteList: '',\n    single: false,\n  };\n\n  constructor(config?: Partial<TextReaderConfig>) {\n    this.config = { ...this.config, ...config };\n    this.scheduler = createScheduler();\n  }\n\n  /** @inheritDoc */\n  public async load(): Promise<void> {\n    const { workerConfig, tesseractConfig } = this.getTesseractConfig();\n    const addThread = async () => {\n      const worker = createWorker(workerConfig);\n\n      await worker.load();\n      await worker.loadLanguage(this.language);\n      await worker.initialize(this.language);\n      await worker.setParameters(tesseractConfig);\n\n      this.scheduler.addWorker(worker);\n    };\n\n    await Promise.allSettled(Array(this.config.threadCount).fill(0).map(addThread));\n  }\n\n  /** @inheritDoc */\n  public async read(imageSource: ImageLike): Promise<string> {\n    const { data } = await this.scheduler.addJob('recognize', imageSource);\n\n    // Precaution, as Tesseract sometimes returns multiple chars!\n    return this.config.single ? data.text.slice(0, 1) : data.text;\n  }\n\n  /** @inheritDoc */\n  public async destruct() {\n    await this.scheduler.terminate();\n  }\n\n  /**\n   * \"Translates\" our configuration into Tesseract's.\n   */\n  protected getTesseractConfig = () => {\n    const tesseractConfig: Partial<WorkerParams> = {\n      tessedit_ocr_engine_mode: 2,\n      user_defined_dpi: '300',\n      tessedit_pageseg_mode: '10' as PSM,\n      tessedit_char_whitelist: '123456789',\n    };\n\n    // Configure Tesseract worker to not make external download requests...\n    const workerConfig: Partial<WorkerOptions> = isNode\n      ? {\n          langPath: path.join(__dirname, '..', '..', '..', 'public', 'ocr'),\n          // It should be faster to cache the uncompressed lang data, although there seems to be no\n          // real difference in practice; so we may as well keep the repo smaller.\n          cacheMethod: 'none',\n          gzip: true,\n        }\n      : {\n          langPath: `${process.env.PUBLIC_URL}/ocr`,\n          workerPath: `${process.env.PUBLIC_URL}/ocr/worker.min.js`,\n          corePath: `${process.env.PUBLIC_URL}/ocr/tesseract-core.wasm.js`,\n        };\n\n    return { tesseractConfig, workerConfig };\n  };\n}\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"app\":\"App_app__2ziFi\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"sudokuSolver\":\"SudokuSolver_sudokuSolver__10dvD\"};","import { forwardRef, MutableRefObject, useEffect } from 'react';\n\n// import { onBack, onTabChange } from '../util/browser';\nimport { turnOffCamera, turnOnCamera } from '../util/camera';\n\nexport enum CameraStatus {\n  Loading,\n  Active,\n  Denied,\n  Unavailable,\n}\n\n/**\n * Renders a video feed of the user's camera (if one is available, with permission granted).\n */\nconst Camera = forwardRef<HTMLVideoElement, Props>(({ onStatusUpdate }: Props, ref) => {\n  useEffect(() => {\n    const { current } = ref as MutableRefObject<HTMLVideoElement | null>;\n    if (!current) return () => {};\n    // Prevent Webpack rebuilds from constantly turning my webcam on, in development, despite the\n    // app's tab being minimised! ðŸ™„ (This block will be auto-stripped from the actual build.)\n    if (process.env.NODE_ENV !== 'production' && document.hidden) return () => {};\n\n    turnOnCamera(current, { width: 800, height: 800 }).catch(({ name }) =>\n      onStatusUpdate(name === 'NotAllowedError' ? CameraStatus.Denied : CameraStatus.Unavailable)\n    );\n\n    // Pause the user's camera, when they're not actively using the app (to respect their device's\n    // battery and stop the annoying \"camera-in-use\" icons/webcam lights).\n    // TODO: Reactivate auto camera on/off functionality.\n    // const listenerCleanups: Array<() => void> = [\n    //   onTabChange({\n    //     closed: () => turnOffCamera(current),\n    //     opened: () => turnOnCamera(current),\n    //   }),\n    //   onBack(() => turnOnCamera(current)),\n    // ];\n\n    return () => {\n      turnOffCamera(current);\n      // listenerCleanups.forEach(cleanup => cleanup());\n    };\n  }, [onStatusUpdate, ref]);\n\n  return (\n    <video\n      ref={ref}\n      onLoadedMetadata={() => onStatusUpdate(CameraStatus.Active)}\n      onSuspend={() => onStatusUpdate(CameraStatus.Unavailable)}\n      playsInline\n      muted\n    />\n  );\n});\n\ntype Props = { onStatusUpdate(status: CameraStatus): void };\nexport default Camera;\n","interface Resolution {\n  width: number;\n  height: number;\n}\n\n/**\n * Used for getting the best-possible camera and configuration from `MediaDevices.getUserMedia()`.\n */\nconst idealCameraConstraints = {\n  width: { ideal: 4096 },\n  height: { ideal: 2160 },\n  facingMode: { ideal: 'environment' },\n  focusMode: { ideal: 'continuous' },\n  whiteBalance: { ideal: 'continuous' },\n  exposureMode: { ideal: 'continuous' },\n};\n\n/**\n * Attempts to find the device's main, telephoto, back-facing camera.\n */\nexport const identifyPrimaryCamera = async (): Promise<MediaDeviceInfo | null> => {\n  const inputDevices = await navigator.mediaDevices.enumerateDevices();\n  const cameras = inputDevices.filter(device => device.kind === 'videoinput');\n\n  if (!cameras.length) throw new Error('No camera found.');\n\n  const backFacingCameras = cameras.filter(camera => camera.label.includes('facing back'));\n\n  // For some reason, on phones with multiple cameras, the last one is usually the main one...\n  return backFacingCameras.length ? backFacingCameras[backFacingCameras.length - 1] : null;\n};\n\n/**\n *  Loads video stream into the supplied <video /> element.\n */\nexport const turnOnCamera = async (videoElement: HTMLVideoElement, dimensions?: Resolution) => {\n  const camera = await identifyPrimaryCamera();\n  const constraints = {\n    video: {\n      ...idealCameraConstraints,\n      // Fall back to the OS-selected camera, if our heuristic can't choose one.\n      deviceId: camera?.deviceId ? camera.deviceId : undefined,\n      ...(dimensions && {\n        width: { ideal: dimensions.width },\n        height: { ideal: dimensions.height },\n      }),\n    },\n    audio: false,\n  };\n\n  videoElement.srcObject = await navigator.mediaDevices.getUserMedia(constraints);\n  await videoElement.play();\n};\n\nexport const getFrame = (video: HTMLVideoElement): ImageData | null => {\n  const buffer = document.createElement('canvas');\n  buffer.width = video.videoWidth;\n  buffer.height = video.videoHeight;\n  const ctx = buffer.getContext('2d');\n  if (!ctx) return null;\n\n  ctx.drawImage(video, 0, 0);\n  return ctx.getImageData(0, 0, buffer.width, buffer.height);\n};\n\n/**\n * Ends any streams associated with the <video />, so that the user's camera light turns off.\n */\nexport const turnOffCamera = (videoElement: HTMLVideoElement) => {\n  const stream = videoElement.srcObject as MediaStream;\n  stream.getVideoTracks()[0].stop();\n};\n","/**\n * Some scripts aren't available on npm, as modules or are simply too big to be bundled, in a\n * browser context; so this function will load them \"the old fashioned way\", via script tag.\n *\n * @param url     The url of the script to load (can be relative or absolute).\n * @param timeout The max amount of time the script can take to load, before throwing an Error.\n */\nexport const loadScript = async (url: string, timeout = 10000): Promise<void> => {\n  const script = document.createElement('script');\n\n  if (url.startsWith('http')) script.src = url;\n  else if (url.startsWith('/')) script.src = `${process.env.PUBLIC_URL}${url}`;\n  else script.src = `${process.env.PUBLIC_URL}/${url}`;\n\n  document.body.appendChild(script);\n\n  return new Promise((resolve, reject): void => {\n    const timeoutId = window.setTimeout(\n      () => reject(new Error(`${url} failed to load in time`)),\n      timeout\n    );\n\n    script.addEventListener('load', () => {\n      window.clearTimeout(timeoutId);\n      resolve();\n    });\n  });\n};\n\n/**\n * Loads a mobile console that can be very helpful for debugging on mobile devices.\n * (Eruda's npm package unfortunately doesn't export a module, so we have to manually load it like\n * this.)\n */\nexport const loadMobileConsole = async () => {\n  await loadScript('/mobileConsole.js');\n  // @ts-ignore -- eruda will have been defined globally, by the script.\n  eruda.init();\n};\n\ntype EventHandler = () => void;\ntype TabChangeHandlers = { opened: EventHandler; closed: EventHandler };\ntype CleanUpFunction = () => void;\n\n/**\n * @param opened Function to run when the browser tab/window is reopened.\n * @param closed Function to run when the browser tab/window is closed.\n * @return CleanUp function, to remove the event handler.\n */\nexport const onTabChange = ({ opened, closed }: TabChangeHandlers): CleanUpFunction => {\n  const handler = () => (document.hidden ? closed() : opened());\n  document.addEventListener('visibilitychange', handler);\n\n  return () => document.removeEventListener('visibilitychange', handler);\n};\n\n/**\n * Runs the supplied function when the user navigates back to the site.\n *\n * @return CleanUp function, to remove the event handler.\n */\nexport const onBack = (eventHandler: EventHandler): CleanUpFunction => {\n  const handler = (event: PageTransitionEvent) => event.persisted && eventHandler();\n  window.addEventListener('pageshow', handler, false);\n\n  return () => window.removeEventListener('pageshow', handler);\n};\n","export type Point = [number, number];\n\ntype Rectangle = {\n  x: number;\n  y: number;\n  width: number;\n  height: number;\n};\n\nexport const distance = ([x1, y1]: Point, [x2, y2]: Point): number =>\n  ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** (1 / 2);\n\nexport const closest = (reference: Point, points: Point[]): Point => {\n  const distances = points.map(point => distance(reference, point));\n  let closestDistance = distances[0];\n\n  return points.reduce((closestPoint, point, i) => {\n    if (distances[i] < closestDistance) {\n      closestDistance = distances[i];\n      return point;\n    }\n    return closestPoint;\n  });\n};\n\nexport const measureSides = (coords: Point[]): number[] =>\n  coords.map((coord, i) => distance(coord, coords[i < coords.length - 1 ? i + 1 : 0]));\n\nexport const isPointInsideRect = (point: Point, rect: Rectangle) =>\n  point[0] >= rect.x &&\n  point[1] >= rect.y &&\n  point[0] <= rect.x + rect.width &&\n  point[0] <= rect.y + rect.height;\n","import { closest, isPointInsideRect, measureSides, Point } from '../../util/geometry';\n\n/** {@link https://docs.opencv.org/3.4/dc/dcf/tutorial_js_contour_features.html} */\nconst BOX_DETECTION_THRESHOLD = 0.01;\nconst SQUARE_SHAPE_THRESHOLD = 0.7;\nconst MIN_CHAR_AREA = 0.08;\nconst MAX_CHAR_AREA = 0.8;\nconst MIN_CHAR_ASPECT_RATIO = 0.2;\nconst MAX_CHAR_ASPECT_RATIO = 1.6;\n/** The average lightness threshold below which a cell is assumed empty. */\nconst CELL_EMPTY_THRESHOLD = 230;\nconst CHAR_PADDING = 0.05;\n\n/**\n * Because contours are just a list of numbers, e.g. [x1, y1, x2, y2, x3, y3...].\n */\nexport const getContourPathCoords = (contour: cv.Mat): Point[] => {\n  const pointVector = Array.from(contour.data32S);\n  const coords = Array(4);\n  for (let i = 0; i < 4; i++) coords[i] = pointVector.slice(i * 2, i * 2 + 2);\n\n  return coords;\n};\n\n/**\n * Simplifies the shape, reducing its number of sides.\n */\nexport const simplifyContour = (contour: cv.Mat): cv.Mat => {\n  const simplified = new cv.Mat();\n  const epsilon = BOX_DETECTION_THRESHOLD * cv.arcLength(contour, true);\n\n  cv.approxPolyDP(contour, simplified, epsilon, true);\n  return simplified;\n};\n\n/**\n * Returns true if the contour resembles a square (allowing for varied perspective angles and\n * rotation).\n *\n * @param contour\n * @param container The contour's container, to be used as a size reference.\n * @param minSize   The minimum size of the square (relative to container).\n * @param maxSize   The maximum size of the square (relative to container).\n */\nexport const isContourSquarish = (\n  contour: cv.Mat,\n  container?: cv.Mat,\n  minSize = 0,\n  maxSize = 1\n): boolean => {\n  // If we don't have 4 sides, then it's definitely not a square!\n  if (contour.size().height !== 4) return false;\n  // If there are no size constraints to apply...\n  if (!container) return true;\n\n  // Take the smaller of both sides, to allow for wide aspect ratio sources.\n  const minArea = Math.min(container.rows, container.cols) ** 2 * minSize;\n  const sizeLimit = Math.max(container.rows, container.cols) * maxSize;\n\n  if (cv.contourArea(contour) >= minArea) {\n    const coords = getContourPathCoords(contour);\n\n    // Check that all sides are within ~70% of the longest side.\n    const sortedLengths = measureSides(coords).sort();\n    const longest = sortedLengths.pop();\n    if (!longest) return false;\n\n    return (\n      longest < sizeLimit &&\n      sortedLengths.every(length => length > SQUARE_SHAPE_THRESHOLD * longest)\n    );\n  }\n\n  return false;\n};\n\nexport const cropAndFlatten = (src: cv.Mat, rectangleContour: cv.Mat): cv.Mat => {\n  const [sourceWidth, sourceHeight] = [src.cols, src.rows];\n\n  // Find the corners of the contour (this won't work if the grid is too close to 45Â°).\n  const contourCoords = getContourPathCoords(rectangleContour);\n  const topLeft = closest([0, 0], contourCoords);\n  const topRight = closest([sourceWidth, 0], contourCoords);\n  const bottomLeft = closest([0, sourceHeight], contourCoords);\n  const bottomRight = closest([sourceWidth, sourceHeight], contourCoords);\n\n  // Choose the smallest width and side, for the cropped dimensions.\n  const newWidth = Math.min(topRight[0] - topLeft[0], bottomRight[0] - bottomLeft[0]);\n  const newHeight = Math.min(bottomLeft[1] - topLeft[1], bottomRight[1] - topRight[1]);\n  const flattened = cv.Mat.zeros(newWidth, newHeight, cv.CV_8UC3);\n  const size = new cv.Size(newWidth, newHeight);\n\n  // Produce a transformation matrix and apply it to the warp\n  // see: https://docs.opencv.org/3.4/dd/d52/tutorial_js_geometric_transformations.html\n  const srcTri = cv.matFromArray(4, 1, cv.CV_32FC2, [\n    ...topLeft,\n    ...topRight,\n    ...bottomRight,\n    ...bottomLeft,\n  ]);\n  const dstTri = cv.matFromArray(4, 1, cv.CV_32FC2, [\n    0,\n    0,\n    newWidth,\n    0,\n    newWidth,\n    newHeight,\n    0,\n    newHeight,\n  ]);\n  const transformMatrix = cv.getPerspectiveTransform(srcTri, dstTri);\n  cv.warpPerspective(src, flattened, transformMatrix, size, cv.INTER_LINEAR, cv.BORDER_CONSTANT);\n\n  transformMatrix.delete();\n  srcTri.delete();\n  dstTri.delete();\n\n  return flattened;\n};\n\nexport const split = (src: cv.Mat, rows: number, columns: number): cv.Mat[][] => {\n  const squares: cv.Mat[][] = new Array(rows);\n  const squareWidth = src.cols / columns;\n  const squareHeight = src.rows / rows;\n\n  for (let r = 0; r < rows; r++) {\n    squares[r] = new Array(columns);\n    for (let c = 0; c < columns; c++) {\n      const x = c * squareWidth;\n      const y = r * squareHeight;\n      const crop = new cv.Rect(x, y, squareWidth, squareHeight);\n      squares[r][c] = src.roi(crop);\n    }\n  }\n\n  return squares;\n};\n\nexport const isEmpty = (src: cv.Mat) => {\n  const mean = new cv.Mat(1, 4, cv.CV_64F);\n  const stdDev = new cv.Mat(1, 4, cv.CV_64F);\n  cv.meanStdDev(src, mean, stdDev);\n\n  return mean.doubleAt(0, 0) >= CELL_EMPTY_THRESHOLD;\n};\n\n/**\n * Tesseract is notoriously bad at extracting text from table cells; so we need help it out, by\n * cropping the cell's contents to remove any edges (which can be mistaken for characters).\n */\nexport const cropCellBorders = (src: cv.Mat, binary: cv.Mat): cv.Mat | null => {\n  const cellCenter = [Math.round(binary.rows / 2), Math.round(binary.cols / 2)] as Point;\n  const cellArea = binary.rows * binary.cols;\n  const minArea = MIN_CHAR_AREA * cellArea;\n  const maxArea = MAX_CHAR_AREA * cellArea;\n  const contours = new cv.MatVector();\n  const hierarchy = new cv.Mat();\n\n  cv.findContours(binary, contours, hierarchy, cv.RETR_TREE, cv.CHAIN_APPROX_SIMPLE);\n  hierarchy.delete();\n\n  let largestArea = 0;\n  let largestRect = null;\n\n  for (let i = 0; i < contours.size(); i++) {\n    const contour = contours.get(i);\n    const rect = cv.boundingRect(contour);\n    const area = rect.width * rect.height;\n    const shapeRatio = rect.width / rect.height;\n\n    if (\n      area > minArea &&\n      area < maxArea &&\n      shapeRatio > MIN_CHAR_ASPECT_RATIO &&\n      shapeRatio < MAX_CHAR_ASPECT_RATIO &&\n      isPointInsideRect(cellCenter, rect) &&\n      area > largestArea\n    ) {\n      largestArea = area;\n      largestRect = rect;\n    }\n    contour.delete();\n  }\n\n  if (largestRect !== null) {\n    // OCR really is expensive, so anything we can do before it to eliminate empty cells, generally\n    // saves a lot of work.\n    const binaryCellContents = binary.roi(largestRect);\n    const isCellEmpty = isEmpty(binaryCellContents);\n    binaryCellContents.delete();\n\n    if (!isCellEmpty) {\n      // Padding the contents helps OCR.\n      const padding = Math.round(CHAR_PADDING * cellArea ** (1 / 2));\n\n      // TODO: Explore \"column walking\" method, to identify true upper bounds\n      //      (count at least ~5% black pixels in row, to disambiguate noise?)\n      largestRect.x = Math.max(largestRect.x - padding, 0);\n      largestRect.y = Math.max(largestRect.y - padding, 0);\n\n      // TODO: Pad tall-thin characters' width a bit more?\n      largestRect.width = Math.min(largestRect.width + 2 * padding, src.cols - largestRect.x);\n      largestRect.height = Math.min(largestRect.height + 2 * padding, src.rows - largestRect.y);\n\n      contours.delete();\n      return src.roi(largestRect);\n    }\n  }\n  contours.delete();\n  return null;\n};\n","import isNode from 'detect-node';\n\nimport SudokuScannerInterface, {\n  SudokuDigitImages,\n  SudokuScannerConfig,\n} from '../../types/interfaces/SudokuScanner';\nimport { loadScript } from '../../util/browser';\nimport {\n  cropAndFlatten,\n  cropCellBorders,\n  isContourSquarish,\n  simplifyContour,\n  split,\n} from '../lib/cv';\n\n/**\n * Locates and extracts Sudoku puzzles from a supplied image.\n */\nexport default class SudokuScanner implements SudokuScannerInterface {\n  /** @inheritDoc */\n  protected readonly config: SudokuScannerConfig = {\n    rows: 9,\n    columns: 9,\n    preprocess: {\n      blurRadius: 11,\n      thresholdBlur: 5,\n      thresholdNorm: 2,\n    },\n    minSize: 0.25,\n    maxSize: 0.99,\n  };\n\n  /** The original, unmodified copy we will keep; so that we can later return a clean image. */\n  protected original: cv.Mat;\n  /** The source image, which will be modified for image analysis.  */\n  protected source: cv.Mat;\n  /** The processed versions of the image (undefined, if scan() hasn't been called yet).  */\n  protected processed?: {\n    /** A cropped version of the original image (useful for rendering in a UI). */\n    colour: cv.Mat;\n    /** A black & white copy, to avoid having to redo the image processing in subsequent stages. */\n    binary: cv.Mat;\n  } | null;\n\n  /**\n   * Loads the image to be scanned and applies custom config values, if supplied.\n   */\n  constructor(source: HTMLCanvasElement | ImageData, config?: Partial<SudokuScannerConfig>) {\n    if (!cv) throw new Error('OpenCV must be loaded!');\n\n    this.original =\n      source.constructor.name === 'ImageData' ? cv.matFromImageData(source) : cv.imread(source);\n    this.source = this.original.clone();\n    this.config = { ...this.config, ...config };\n  }\n\n  /** @inheritDoc */\n  public extractSudokuImage(outputCanvas?: HTMLCanvasElement): boolean {\n    // TODO: Check if image is too blurry (see: https://github.com/justadudewhohacks/opencv4nodejs/issues/448)\n    this.preprocessImage();\n    const largestSquare = this.findLargestSquare();\n\n    if (largestSquare !== null) {\n      this.processed = {\n        colour: cropAndFlatten(this.original, largestSquare),\n        binary: cropAndFlatten(this.source, largestSquare),\n      };\n\n      largestSquare.delete();\n      this.original.delete();\n      this.source.delete();\n\n      outputCanvas && cv.imshow(outputCanvas, this.processed.colour);\n      return true;\n    }\n\n    this.processed = null;\n    return false;\n  }\n\n  /** @inheritDoc */\n  public extractDigits(): SudokuDigitImages | null {\n    // If we didn't find a Sudoku, then we won't find any digits...\n    if (this.processed === null) return null;\n\n    // If we haven't scanned the image for Sudokus yet, we need to...\n    if (this.processed === undefined) {\n      this.extractSudokuImage();\n      return this.extractDigits();\n    }\n\n    const originalCells = split(this.processed.colour, this.config.rows, this.config.columns);\n    const binaryCells = split(this.processed.binary, this.config.rows, this.config.columns);\n    const grid: (HTMLCanvasElement | null)[][] = [];\n\n    for (let r = 0; r < this.config.rows; r++) {\n      const row = [];\n\n      for (let c = 0; c < this.config.columns; c++) {\n        const colourCell = originalCells[r][c];\n        const binaryCell = binaryCells[r][c];\n        const digitMat = cropCellBorders(colourCell, binaryCell);\n\n        if (digitMat) {\n          const canvas = document.createElement('canvas');\n          row.push(canvas);\n          cv.imshow(canvas, digitMat);\n\n          digitMat.delete();\n        } else row.push(null);\n\n        colourCell.delete();\n        binaryCell.delete();\n      }\n\n      grid.push(row);\n    }\n\n    return grid;\n  }\n\n  /** @inheritDoc */\n  public destruct(): void {\n    // If the image has been processed, then the this.original and this.source matrices have already\n    // been deleted.\n    if (this.processed) {\n      this.processed.colour.delete();\n      this.processed.binary.delete();\n    } else {\n      this.original.delete();\n      this.source.delete();\n    }\n  }\n\n  /**\n   * Applies image thresholding, to make the source image as close to black & white \"line art\" as\n   * possible (i.e. with the goal of finding contiguous lines, with minimal noise).\n   */\n  protected preprocessImage(): void {\n    const { blurRadius, thresholdBlur, thresholdNorm } = this.config.preprocess;\n\n    // Grayscale, to help line-identification.\n    cv.cvtColor(this.source, this.source, cv.COLOR_RGBA2GRAY, 0);\n    // Blur, to smooth out noise.\n    const blurKernel = new cv.Size(blurRadius, blurRadius);\n    cv.GaussianBlur(this.source, this.source, blurKernel, 0, 0, cv.BORDER_DEFAULT);\n    // Convert to black & white.\n    cv.adaptiveThreshold(\n      this.source,\n      this.source,\n      255, // black\n      cv.ADAPTIVE_THRESH_MEAN_C,\n      cv.THRESH_BINARY,\n      thresholdBlur,\n      thresholdNorm\n    );\n  }\n\n  /**\n   * Finds the contour (shape, in OpenCV) surrounding the largest Sudoku-like square in the source\n   * image.\n   */\n  protected findLargestSquare(): cv.Mat | null {\n    const contours = new cv.MatVector();\n    const hierarchy = new cv.Mat();\n\n    cv.findContours(this.source, contours, hierarchy, cv.RETR_TREE, cv.CHAIN_APPROX_SIMPLE);\n\n    let largestArea = 0;\n    let largestSquare = null;\n\n    for (let i = 0; i < contours.size(); i++) {\n      const contour = contours.get(i);\n      const simplified = simplifyContour(contour);\n\n      // TODO: Add additional constraints, e.g.parallel Hough lines, to reduce false positives?\n      if (isContourSquarish(simplified, this.source, this.config.minSize, this.config.maxSize)) {\n        const area = cv.contourArea(simplified);\n        if (area > largestArea) {\n          largestArea = area;\n          largestSquare = simplified.clone();\n        }\n      }\n      contour.delete();\n      simplified.delete();\n    }\n\n    contours.delete();\n    hierarchy.delete();\n\n    return largestSquare;\n  }\n\n  /**\n   * Loads the Scanner's dependencies in a browser context (please note, this must be done manually\n   * if using node). This must be have resolved before the class is used.\n   *\n   * @param timeLimit The time, in ms, after which an Error will be thrown, if the dependencies have\n   *                  not loaded.\n   */\n  static async loadDependencies(timeLimit?: number): Promise<void> {\n    if (isNode || typeof cv !== 'undefined') return Promise.resolve();\n\n    return loadScript('opencv.js', timeLimit);\n  }\n}\n","import { useCallback, useEffect, useMemo, useRef, useState } from 'react';\n\nimport { SudokuScanner as SudokuScannerService, TextReader } from '../services';\nimport { SudokuDigitImages } from '../types/interfaces/SudokuScanner';\nimport { Sudoku } from '../types/interfaces/SudokuSolver';\nimport { getFrame } from '../util/camera';\n\n/**\n * Visual UI, designed to be rendered on top of the <video> element that is its source. The video\n * source is scanned for Sudoku-like objects.\n */\nexport default function SudokuScanner({ source, onFound, scanHz = 30 }: Props) {\n  const [loadingStarted, setLoadingStarted] = useState(false);\n  const [scannerLoaded, setScannerLoaded] = useState(false);\n  const [readerLoaded, setReaderLoaded] = useState(false);\n  const [digitImages, setDigitImages] = useState<SudokuDigitImages | null>(null);\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n  const digitReader = useMemo(() => new TextReader({ whiteList: '123456789', single: true }), []);\n\n  /**\n   * Continuously scan the source video, until a sudoku-like image is found.\n   */\n  const scanSource = useCallback(() => {\n    const start = Date.now();\n    let found = false;\n\n    if (source && canvasRef.current) {\n      const frame = getFrame(source);\n      if (frame) {\n        const scanner = new SudokuScannerService(frame);\n        found = scanner.extractSudokuImage(canvasRef.current);\n        found && setDigitImages(scanner.extractDigits());\n        scanner.destruct();\n      }\n    }\n\n    const timeTaken = Date.now() - start;\n    !found && window.setTimeout(scanSource, 1000 / scanHz - timeTaken);\n  }, [scanHz, source]);\n\n  /**\n   * Runs OCR on `digitImages`, if is populated. The resulting 2D array of numbers, is used to\n   * build a Sudoku object, which is returned to the parent via `onFound()`.\n   */\n  const readPendingDigits = useCallback(\n    () =>\n      digitImages &&\n      Promise.all(\n        digitImages.map(row =>\n          Promise.all(row.map(digit => (digit ? digitReader.read(digit) : '')))\n        )\n      ).then(onFound),\n    [digitImages, onFound, digitReader]\n  );\n\n  useEffect(() => {\n    // Both the SudokuScanner and TextReader have large (~10+ MB) dependencies to load (which, even\n    // if cached, can still take several seconds to parse). We want to make the experience seem as\n    // fast as possible for the user; so we proceed as far as we can at each step, before hitting a\n    // roadblock (where we are forced to display a \"this library is loading...\" message).\n    if (!loadingStarted) {\n      SudokuScannerService.loadDependencies().then(() => {\n        scanSource();\n        setScannerLoaded(true);\n      });\n      digitReader.load().then(() => {\n        readPendingDigits();\n        setReaderLoaded(true);\n      });\n      setLoadingStarted(true);\n    }\n  }, [loadingStarted, readPendingDigits, digitReader, scanSource]);\n\n  useEffect(() => {\n    if (readerLoaded) readPendingDigits();\n  }, [readPendingDigits, readerLoaded]);\n\n  useEffect(\n    () => () => {\n      // It's safer to call the destructor here, in case the component is unmounted before a sudoku\n      // is found.\n      // TODO: Move scanner and reader into global or parent state.\n      digitReader.destruct();\n    },\n    [digitReader]\n  );\n\n  return (\n    <div>\n      {!scannerLoaded && 'Please wait while the scanner loads...'}\n      {digitImages && !readerLoaded && 'Please wait while the reader loads...'}\n      <canvas ref={canvasRef} />\n    </div>\n  );\n}\n\ntype Props = { source: HTMLVideoElement | null; onFound(sudoku: Sudoku): void; scanHz?: number };\n","import { Sudoku } from '../types/interfaces/SudokuSolver';\nimport styles from './SudokuSolver.module.scss';\n\nexport default function SudokuSolver({ sudoku }: { sudoku: Sudoku }) {\n  let i = 0;\n  return (\n    <table className={styles.sudokuSolver}>\n      <tbody>\n        {sudoku.map(row => (\n          <tr key={i}>\n            {row.map(cell => (\n              // eslint-disable-next-line no-plusplus -- ðŸ™„\n              <td key={i++}>{cell}</td>\n            ))}\n          </tr>\n        ))}\n      </tbody>\n    </table>\n  );\n}\n","import { useRef, useState } from 'react';\n\nimport styles from './App.module.scss';\nimport { Camera, CameraStatus, SudokuScanner, SudokuSolver } from './components';\nimport { Sudoku } from './types/interfaces/SudokuSolver';\n\nexport default function App() {\n  const [cameraStatus, setCameraStatus] = useState(CameraStatus.Loading);\n  const [sudoku, setSudoku] = useState<Sudoku | null>(null);\n  const videoRef = useRef<HTMLVideoElement>(null);\n\n  return (\n    <div className={styles.app}>\n      <header>\n        <h1>ðŸ§® Sudoku Solver</h1>\n      </header>\n      <main>\n        <Camera ref={videoRef} onStatusUpdate={setCameraStatus} />\n        {cameraStatus === CameraStatus.Active && !sudoku && (\n          <SudokuScanner source={videoRef.current} scanHz={10} onFound={setSudoku} />\n        )}\n        {sudoku && <SudokuSolver sudoku={sudoku} />}\n      </main>\n      <footer>\n        <nav>\n          {sudoku && (\n            <button type=\"button\" onClick={() => setSudoku(null)}>\n              Reset\n            </button>\n          )}\n        </nav>\n      </footer>\n    </div>\n  );\n}\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://cra.link/PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(/^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/)\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL || '', window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://cra.link/PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://cra.link/PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log('No internet connection found. App is running in offline mode.');\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import './index.scss';\n\nimport React from 'react';\nimport ReactDOM from 'react-dom';\n\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\nimport * as serviceWorkerRegistration from './serviceWorkerRegistration';\nimport { loadMobileConsole } from './util/browser';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\nwindow.location.search.includes('console') && loadMobileConsole();\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://cra.link/PWA\nserviceWorkerRegistration.unregister();\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}